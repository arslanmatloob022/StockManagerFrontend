const e="object"==typeof self?self:globalThis,t=t=>((t,r)=>{const s=(e,r)=>(t.set(r,e),e),n=c=>{if(t.has(c))return t.get(c);const[o,u]=r[c];switch(o){case 0:case-1:return s(u,c);case 1:{const e=s([],c);for(const t of u)e.push(n(t));return e}case 2:{const e=s({},c);for(const[t,r]of u)e[n(t)]=n(r);return e}case 3:return s(new Date(u),c);case 4:{const{source:e,flags:t}=u;return s(new RegExp(e,t),c)}case 5:{const e=s(new Map,c);for(const[t,r]of u)e.set(n(t),n(r));return e}case 6:{const e=s(new Set,c);for(const t of u)e.add(n(t));return e}case 7:{const{name:t,message:r}=u;return s(new e[t](r),c)}case 8:return s(BigInt(u),c);case"BigInt":return s(Object(BigInt(u)),c)}return s(new e[o](u),c)};return n})(new Map,t)(0),r="",{toString:s}={},{keys:n}=Object,c=e=>{const t=typeof e;if("object"!==t||!e)return[0,t];const n=s.call(e).slice(8,-1);switch(n){case"Array":return[1,r];case"Object":return[2,r];case"Date":return[3,r];case"RegExp":return[4,r];case"Map":return[5,r];case"Set":return[6,r]}return n.includes("Array")?[1,n]:n.includes("Error")?[7,n]:[2,n]},o=([e,t])=>0===e&&("function"===t||"symbol"===t),u=(e,{json:t,lossy:r}={})=>{const s=[];return((e,t,r,s)=>{const u=(e,t)=>{const n=s.push(e)-1;return r.set(t,n),n},a=s=>{if(r.has(s))return r.get(s);let[f,i]=c(s);switch(f){case 0:{let t=s;switch(i){case"bigint":f=8,t=s.toString();break;case"function":case"symbol":if(e)throw new TypeError("unable to serialize "+i);t=null;break;case"undefined":return u([-1],s)}return u([f,t],s)}case 1:{if(i)return u([i,[...s]],s);const e=[],t=u([f,e],s);for(const r of s)e.push(a(r));return t}case 2:{if(i)switch(i){case"BigInt":return u([i,s.toString()],s);case"Boolean":case"Number":case"String":return u([i,s.valueOf()],s)}if(t&&"toJSON"in s)return a(s.toJSON());const r=[],l=u([f,r],s);for(const t of n(s))!e&&o(c(s[t]))||r.push([a(t),a(s[t])]);return l}case 3:return u([f,s.toISOString()],s);case 4:{const{source:e,flags:t}=s;return u([f,{source:e,flags:t}],s)}case 5:{const t=[],r=u([f,t],s);for(const[n,u]of s)(e||!o(c(n))&&!o(c(u)))&&t.push([a(n),a(u)]);return r}case 6:{const t=[],r=u([f,t],s);for(const n of s)!e&&o(c(n))||t.push(a(n));return r}}const{message:l}=s;return u([f,{name:i,message:l}],s)};return a})(!(t||r),!!t,new Map,s)(e),s},a="function"==typeof structuredClone?(e,r)=>r&&("json"in r||"lossy"in r)?t(u(e,r)):structuredClone(e):(e,r)=>t(u(e,r));export{a as s};
