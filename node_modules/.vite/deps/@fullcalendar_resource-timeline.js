import {
  DEFAULT_RESOURCE_ORDER,
  ResourceApi,
  ResourceSplitter,
  buildResourceFields,
  buildRowNodes,
  getPublicId,
  index as index2,
  isGroupsEqual,
  refineRenderProps$1
} from "./chunk-Z5MWOR5S.js";
import {
  ScrollGrid
} from "./chunk-7V3XRFPG.js";
import {
  index
} from "./chunk-XT3PLC24.js";
import "./chunk-T7UM46HU.js";
import {
  BaseComponent,
  BgEvent,
  ContentContainer,
  DateComponent,
  MoreLinkContainer,
  NowIndicatorContainer,
  NowTimer,
  PositionCache,
  RefMap,
  SegHierarchy,
  Slicer,
  StandardEvent,
  ViewContainer,
  _,
  addDays,
  addMs,
  asCleanDays,
  asRoughMinutes,
  asRoughMs,
  asRoughSeconds,
  buildEventRangeKey,
  buildIsoString,
  buildNavLinkAttrs,
  computeEarliestSegStart,
  computeVisibleDayRange,
  config,
  createDuration,
  createFormatter,
  createPlugin,
  d,
  diffWholeDays,
  elementClosest,
  findDirectChildren,
  findElements,
  getDateMeta,
  getDayClassNames,
  getSegMeta,
  getSlotClassNames,
  getStickyFooterScrollbar,
  getStickyHeaderDates,
  greatestDurationDenominator,
  groupIntersectingEntries,
  injectStyles,
  intersectRanges,
  isArraysEqual,
  isInt,
  isPropsEqual,
  mapHash,
  memoize,
  memoizeObjArg,
  multiplyDuration,
  padStart,
  rangeContainsMarker,
  renderFill,
  renderScrollShim,
  sortEventSegs,
  startOfDay,
  wholeDivideDurations,
  y
} from "./chunk-QXEJWH2N.js";
import "./chunk-2LSFTFF7.js";

// node_modules/@fullcalendar/timeline/internal.js
var MIN_AUTO_LABELS = 18;
var MAX_AUTO_SLOTS_PER_LABEL = 6;
var MAX_AUTO_CELLS = 200;
config.MAX_TIMELINE_SLOTS = 1e3;
var STOCK_SUB_DURATIONS = [
  { years: 1 },
  { months: 1 },
  { days: 1 },
  { hours: 1 },
  { minutes: 30 },
  { minutes: 15 },
  { minutes: 10 },
  { minutes: 5 },
  { minutes: 1 },
  { seconds: 30 },
  { seconds: 15 },
  { seconds: 10 },
  { seconds: 5 },
  { seconds: 1 },
  { milliseconds: 500 },
  { milliseconds: 100 },
  { milliseconds: 10 },
  { milliseconds: 1 }
];
function buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {
  let tDateProfile = {
    labelInterval: allOptions.slotLabelInterval,
    slotDuration: allOptions.slotDuration
  };
  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv);
  ensureLabelInterval(tDateProfile, dateProfile, dateEnv);
  ensureSlotDuration(tDateProfile, dateProfile, dateEnv);
  let input = allOptions.slotLabelFormat;
  let rawFormats = Array.isArray(input) ? input : input != null ? [input] : computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);
  tDateProfile.headerFormats = rawFormats.map((rawFormat) => createFormatter(rawFormat));
  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);
  let largeUnit = null;
  if (!tDateProfile.isTimeScale) {
    const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;
    if (/year|month|week/.test(slotUnit)) {
      largeUnit = slotUnit;
    }
  }
  tDateProfile.largeUnit = largeUnit;
  tDateProfile.emphasizeWeeks = asCleanDays(tDateProfile.slotDuration) === 1 && currentRangeAs("weeks", dateProfile, dateEnv) >= 2 && !allOptions.businessHours;
  let rawSnapDuration = allOptions.snapDuration;
  let snapDuration;
  let snapsPerSlot;
  if (rawSnapDuration) {
    snapDuration = createDuration(rawSnapDuration);
    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration);
  }
  if (snapsPerSlot == null) {
    snapDuration = tDateProfile.slotDuration;
    snapsPerSlot = 1;
  }
  tDateProfile.snapDuration = snapDuration;
  tDateProfile.snapsPerSlot = snapsPerSlot;
  let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime);
  let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);
  let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv);
  if (tDateProfile.isTimeScale) {
    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);
    normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);
  }
  tDateProfile.timeWindowMs = timeWindowMs;
  tDateProfile.normalizedRange = { start: normalizedStart, end: normalizedEnd };
  let slotDates = [];
  let date = normalizedStart;
  while (date < normalizedEnd) {
    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {
      slotDates.push(date);
    }
    date = dateEnv.add(date, tDateProfile.slotDuration);
  }
  tDateProfile.slotDates = slotDates;
  let snapIndex = -1;
  let snapDiff = 0;
  const snapDiffToIndex = [];
  const snapIndexToDiff = [];
  date = normalizedStart;
  while (date < normalizedEnd) {
    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {
      snapIndex += 1;
      snapDiffToIndex.push(snapIndex);
      snapIndexToDiff.push(snapDiff);
    } else {
      snapDiffToIndex.push(snapIndex + 0.5);
    }
    date = dateEnv.add(date, tDateProfile.snapDuration);
    snapDiff += 1;
  }
  tDateProfile.snapDiffToIndex = snapDiffToIndex;
  tDateProfile.snapIndexToDiff = snapIndexToDiff;
  tDateProfile.snapCnt = snapIndex + 1;
  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot;
  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);
  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);
  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);
  return tDateProfile;
}
function normalizeDate(date, tDateProfile, dateEnv) {
  let normalDate = date;
  if (!tDateProfile.isTimeScale) {
    normalDate = startOfDay(normalDate);
    if (tDateProfile.largeUnit) {
      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);
    }
  }
  return normalDate;
}
function normalizeRange(range, tDateProfile, dateEnv) {
  if (!tDateProfile.isTimeScale) {
    range = computeVisibleDayRange(range);
    if (tDateProfile.largeUnit) {
      let dayRange = range;
      range = {
        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),
        end: dateEnv.startOf(range.end, tDateProfile.largeUnit)
      };
      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {
        range = {
          start: range.start,
          end: dateEnv.add(range.end, tDateProfile.slotDuration)
        };
      }
    }
  }
  return range;
}
function isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {
  if (dateProfileGenerator.isHiddenDay(date)) {
    return false;
  }
  if (tDateProfile.isTimeScale) {
    let day = startOfDay(date);
    let timeMs = date.valueOf() - day.valueOf();
    let ms = timeMs - asRoughMs(dateProfile.slotMinTime);
    ms = (ms % 864e5 + 864e5) % 864e5;
    return ms < tDateProfile.timeWindowMs;
  }
  return true;
}
function validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {
  const { currentRange } = dateProfile;
  if (tDateProfile.labelInterval) {
    const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);
    if (labelCnt > config.MAX_TIMELINE_SLOTS) {
      console.warn("slotLabelInterval results in too many cells");
      tDateProfile.labelInterval = null;
    }
  }
  if (tDateProfile.slotDuration) {
    const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);
    if (slotCnt > config.MAX_TIMELINE_SLOTS) {
      console.warn("slotDuration results in too many cells");
      tDateProfile.slotDuration = null;
    }
  }
  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {
    const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);
    if (slotsPerLabel === null || slotsPerLabel < 1) {
      console.warn("slotLabelInterval must be a multiple of slotDuration");
      tDateProfile.slotDuration = null;
    }
  }
}
function ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {
  const { currentRange } = dateProfile;
  let { labelInterval } = tDateProfile;
  if (!labelInterval) {
    let input;
    if (tDateProfile.slotDuration) {
      for (input of STOCK_SUB_DURATIONS) {
        const tryLabelInterval = createDuration(input);
        const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);
        if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {
          labelInterval = tryLabelInterval;
          break;
        }
      }
      if (!labelInterval) {
        labelInterval = tDateProfile.slotDuration;
      }
    } else {
      for (input of STOCK_SUB_DURATIONS) {
        labelInterval = createDuration(input);
        const labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);
        if (labelCnt >= MIN_AUTO_LABELS) {
          break;
        }
      }
    }
    tDateProfile.labelInterval = labelInterval;
  }
  return labelInterval;
}
function ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {
  const { currentRange } = dateProfile;
  let { slotDuration } = tDateProfile;
  if (!slotDuration) {
    const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv);
    for (let input of STOCK_SUB_DURATIONS) {
      const trySlotDuration = createDuration(input);
      const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);
      if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {
        slotDuration = trySlotDuration;
        break;
      }
    }
    if (slotDuration) {
      const slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);
      if (slotCnt > MAX_AUTO_CELLS) {
        slotDuration = null;
      }
    }
    if (!slotDuration) {
      slotDuration = labelInterval;
    }
    tDateProfile.slotDuration = slotDuration;
  }
  return slotDuration;
}
function computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {
  let format1;
  let format2;
  const { labelInterval } = tDateProfile;
  let unit = greatestDurationDenominator(labelInterval).unit;
  const weekNumbersVisible = allOptions.weekNumbers;
  let format0 = format1 = format2 = null;
  if (unit === "week" && !weekNumbersVisible) {
    unit = "day";
  }
  switch (unit) {
    case "year":
      format0 = { year: "numeric" };
      break;
    case "month":
      if (currentRangeAs("years", dateProfile, dateEnv) > 1) {
        format0 = { year: "numeric" };
      }
      format1 = { month: "short" };
      break;
    case "week":
      if (currentRangeAs("years", dateProfile, dateEnv) > 1) {
        format0 = { year: "numeric" };
      }
      format1 = { week: "narrow" };
      break;
    case "day":
      if (currentRangeAs("years", dateProfile, dateEnv) > 1) {
        format0 = { year: "numeric", month: "long" };
      } else if (currentRangeAs("months", dateProfile, dateEnv) > 1) {
        format0 = { month: "long" };
      }
      if (weekNumbersVisible) {
        format1 = { week: "short" };
      }
      format2 = { weekday: "narrow", day: "numeric" };
      break;
    case "hour":
      if (weekNumbersVisible) {
        format0 = { week: "short" };
      }
      if (currentRangeAs("days", dateProfile, dateEnv) > 1) {
        format1 = { weekday: "short", day: "numeric", month: "numeric", omitCommas: true };
      }
      format2 = {
        hour: "numeric",
        minute: "2-digit",
        omitZeroMinute: true,
        meridiem: "short"
      };
      break;
    case "minute":
      if (asRoughMinutes(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {
        format0 = {
          hour: "numeric",
          meridiem: "short"
        };
        format1 = (params) => ":" + padStart(params.date.minute, 2);
      } else {
        format0 = {
          hour: "numeric",
          minute: "numeric",
          meridiem: "short"
        };
      }
      break;
    case "second":
      if (asRoughSeconds(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {
        format0 = { hour: "numeric", minute: "2-digit", meridiem: "lowercase" };
        format1 = (params) => ":" + padStart(params.date.second, 2);
      } else {
        format0 = { hour: "numeric", minute: "2-digit", second: "2-digit", meridiem: "lowercase" };
      }
      break;
    case "millisecond":
      format0 = { hour: "numeric", minute: "2-digit", second: "2-digit", meridiem: "lowercase" };
      format1 = (params) => "." + padStart(params.millisecond, 3);
      break;
  }
  return [].concat(format0 || [], format1 || [], format2 || []);
}
function currentRangeAs(unit, dateProfile, dateEnv) {
  let range = dateProfile.currentRange;
  let res = null;
  if (unit === "years") {
    res = dateEnv.diffWholeYears(range.start, range.end);
  } else if (unit === "months") {
    res = dateEnv.diffWholeMonths(range.start, range.end);
  } else if (unit === "weeks") {
    res = dateEnv.diffWholeMonths(range.start, range.end);
  } else if (unit === "days") {
    res = diffWholeDays(range.start, range.end);
  }
  return res || 0;
}
function buildIsWeekStarts(tDateProfile, dateEnv) {
  let { slotDates, emphasizeWeeks } = tDateProfile;
  let prevWeekNumber = null;
  let isWeekStarts = [];
  for (let slotDate of slotDates) {
    let weekNumber = dateEnv.computeWeekNumber(slotDate);
    let isWeekStart = emphasizeWeeks && prevWeekNumber !== null && prevWeekNumber !== weekNumber;
    prevWeekNumber = weekNumber;
    isWeekStarts.push(isWeekStart);
  }
  return isWeekStarts;
}
function buildCellRows(tDateProfile, dateEnv) {
  let slotDates = tDateProfile.slotDates;
  let formats = tDateProfile.headerFormats;
  let cellRows = formats.map(() => []);
  let slotAsDays = asCleanDays(tDateProfile.slotDuration);
  let guessedSlotUnit = slotAsDays === 7 ? "week" : slotAsDays === 1 ? "day" : null;
  let rowUnitsFromFormats = formats.map((format) => format.getLargestUnit ? format.getLargestUnit() : null);
  for (let i = 0; i < slotDates.length; i += 1) {
    let date = slotDates[i];
    let isWeekStart = tDateProfile.isWeekStarts[i];
    for (let row = 0; row < formats.length; row += 1) {
      let format = formats[row];
      let rowCells = cellRows[row];
      let leadingCell = rowCells[rowCells.length - 1];
      let isLastRow = row === formats.length - 1;
      let isSuperRow = formats.length > 1 && !isLastRow;
      let newCell = null;
      let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);
      if (isSuperRow) {
        let text = dateEnv.format(date, format);
        if (!leadingCell || leadingCell.text !== text) {
          newCell = buildCellObject(date, text, rowUnit);
        } else {
          leadingCell.colspan += 1;
        }
      } else if (!leadingCell || isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {
        let text = dateEnv.format(date, format);
        newCell = buildCellObject(date, text, rowUnit);
      } else {
        leadingCell.colspan += 1;
      }
      if (newCell) {
        newCell.weekStart = isWeekStart;
        rowCells.push(newCell);
      }
    }
  }
  return cellRows;
}
function buildCellObject(date, text, rowUnit) {
  return { date, text, rowUnit, colspan: 1, isWeekStart: false };
}
var TimelineHeaderTh = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
    this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);
  }
  render() {
    let { props, context } = this;
    let { dateEnv, options } = context;
    let { cell, dateProfile, tDateProfile } = props;
    let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);
    let renderProps = this.refineRenderProps({
      level: props.rowLevel,
      dateMarker: cell.date,
      text: cell.text,
      dateEnv: context.dateEnv,
      viewApi: context.viewApi
    });
    return y(ContentContainer, { elTag: "th", elClasses: [
      "fc-timeline-slot",
      "fc-timeline-slot-label",
      cell.isWeekStart && "fc-timeline-slot-em",
      ...// TODO: so slot classnames for week/month/bigger. see note above about rowUnit
      cell.rowUnit === "time" ? getSlotClassNames(dateMeta, context.theme) : getDayClassNames(dateMeta, context.theme)
    ], elAttrs: {
      colSpan: cell.colspan,
      "data-date": dateEnv.formatIso(cell.date, {
        omitTime: !tDateProfile.isTimeScale,
        omitTimeZoneOffset: true
      })
    }, renderProps, generatorName: "slotLabelContent", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-timeline-slot-frame", style: { height: props.rowInnerHeight } },
      y(InnerContent, { elTag: "a", elClasses: [
        "fc-timeline-slot-cushion",
        "fc-scrollgrid-sync-inner",
        props.isSticky && "fc-sticky"
      ], elAttrs: this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit) })
    ));
  }
};
function buildCellNavLinkAttrs(context, cellDate, rowUnit) {
  return rowUnit && rowUnit !== "time" ? buildNavLinkAttrs(context, cellDate, rowUnit) : {};
}
function renderInnerContent(renderProps) {
  return renderProps.text;
}
function refineRenderProps(input) {
  return {
    level: input.level,
    date: input.dateEnv.toDate(input.dateMarker),
    view: input.viewApi,
    text: input.text
  };
}
var TimelineHeaderRows = class extends BaseComponent {
  render() {
    let { dateProfile, tDateProfile, rowInnerHeights, todayRange, nowDate } = this.props;
    let { cellRows } = tDateProfile;
    return y(_, null, cellRows.map((rowCells, rowLevel) => {
      let isLast = rowLevel === cellRows.length - 1;
      let isChrono = tDateProfile.isTimeScale && isLast;
      let classNames = [
        "fc-timeline-header-row",
        isChrono ? "fc-timeline-header-row-chrono" : ""
      ];
      return (
        // eslint-disable-next-line react/no-array-index-key
        y("tr", { key: rowLevel, className: classNames.join(" ") }, rowCells.map((cell) => y(TimelineHeaderTh, { key: cell.date.toISOString(), cell, rowLevel, dateProfile, tDateProfile, todayRange, nowDate, rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel], isSticky: !isLast })))
      );
    }));
  }
};
var TimelineCoords = class {
  constructor(slatRootEl, slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {
    this.slatRootEl = slatRootEl;
    this.dateProfile = dateProfile;
    this.tDateProfile = tDateProfile;
    this.dateEnv = dateEnv;
    this.isRtl = isRtl;
    this.outerCoordCache = new PositionCache(
      slatRootEl,
      slatEls,
      true,
      // isHorizontal
      false
    );
    this.innerCoordCache = new PositionCache(
      slatRootEl,
      findDirectChildren(slatEls, "div"),
      true,
      // isHorizontal
      false
    );
  }
  isDateInRange(date) {
    return rangeContainsMarker(this.dateProfile.currentRange, date);
  }
  // results range from negative width of area to 0
  dateToCoord(date) {
    let { tDateProfile } = this;
    let snapCoverage = this.computeDateSnapCoverage(date);
    let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;
    let slotIndex = Math.floor(slotCoverage);
    slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);
    let partial = slotCoverage - slotIndex;
    let { innerCoordCache, outerCoordCache } = this;
    if (this.isRtl) {
      return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] - innerCoordCache.getWidth(slotIndex) * partial);
    }
    return outerCoordCache.lefts[slotIndex] + innerCoordCache.getWidth(slotIndex) * partial;
  }
  rangeToCoords(range) {
    return {
      start: this.dateToCoord(range.start),
      end: this.dateToCoord(range.end)
    };
  }
  durationToCoord(duration) {
    let { dateProfile, tDateProfile, dateEnv, isRtl } = this;
    let coord = 0;
    if (dateProfile) {
      let date = dateEnv.add(dateProfile.activeRange.start, duration);
      if (!tDateProfile.isTimeScale) {
        date = startOfDay(date);
      }
      coord = this.dateToCoord(date);
      if (!isRtl && coord) {
        coord += 1;
      }
    }
    return coord;
  }
  coordFromLeft(coord) {
    if (this.isRtl) {
      return this.outerCoordCache.originClientRect.width - coord;
    }
    return coord;
  }
  // returned value is between 0 and the number of snaps
  computeDateSnapCoverage(date) {
    return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);
  }
};
function computeDateSnapCoverage(date, tDateProfile, dateEnv) {
  let snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);
  if (snapDiff < 0) {
    return 0;
  }
  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {
    return tDateProfile.snapCnt;
  }
  let snapDiffInt = Math.floor(snapDiff);
  let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];
  if (isInt(snapCoverage)) {
    snapCoverage += snapDiff - snapDiffInt;
  } else {
    snapCoverage = Math.ceil(snapCoverage);
  }
  return snapCoverage;
}
function coordToCss(hcoord, isRtl) {
  if (hcoord === null) {
    return { left: "", right: "" };
  }
  if (isRtl) {
    return { right: hcoord, left: "" };
  }
  return { left: hcoord, right: "" };
}
function coordsToCss(hcoords, isRtl) {
  if (!hcoords) {
    return { left: "", right: "" };
  }
  if (isRtl) {
    return { right: hcoords.start, left: -hcoords.end };
  }
  return { left: hcoords.start, right: -hcoords.end };
}
var TimelineHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
  }
  render() {
    let { props, context } = this;
    let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit;
    let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;
    return y(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => y(
      "div",
      { className: "fc-timeline-header", ref: this.rootElRef },
      y(
        "table",
        { "aria-hidden": true, className: "fc-scrollgrid-sync-table", style: { minWidth: props.tableMinWidth, width: props.clientWidth } },
        props.tableColGroupNode,
        y(
          "tbody",
          null,
          y(TimelineHeaderRows, { dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate, todayRange, rowInnerHeights: props.rowInnerHeights })
        )
      ),
      context.options.nowIndicator && // need to have a container regardless of whether the current view has a visible now indicator
      // because apparently removal of the element resets the scroll for some reasons (issue #5351).
      // this issue doesn't happen for the timeline body however (
      y("div", { className: "fc-timeline-now-indicator-container" }, slatCoords && slatCoords.isDateInRange(nowDate) && y(NowIndicatorContainer, { elClasses: ["fc-timeline-now-indicator-arrow"], elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl), isAxis: true, date: nowDate }))
    ));
  }
  componentDidMount() {
    this.updateSize();
  }
  componentDidUpdate() {
    this.updateSize();
  }
  updateSize() {
    if (this.props.onMaxCushionWidth) {
      this.props.onMaxCushionWidth(this.computeMaxCushionWidth());
    }
  }
  computeMaxCushionWidth() {
    return Math.max(...findElements(this.rootElRef.current, ".fc-timeline-header-row:last-child .fc-timeline-slot-cushion").map((el) => el.getBoundingClientRect().width));
  }
};
var TimelineSlatCell = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { dateEnv, options, theme } = context;
    let { date, tDateProfile, isEm } = props;
    let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);
    let renderProps = Object.assign(Object.assign({ date: dateEnv.toDate(props.date) }, dateMeta), { view: context.viewApi });
    return y(ContentContainer, { elTag: "td", elRef: props.elRef, elClasses: [
      "fc-timeline-slot",
      "fc-timeline-slot-lane",
      isEm && "fc-timeline-slot-em",
      tDateProfile.isTimeScale ? isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ? "fc-timeline-slot-major" : "fc-timeline-slot-minor" : "",
      ...props.isDay ? getDayClassNames(dateMeta, theme) : getSlotClassNames(dateMeta, theme)
    ], elAttrs: {
      "data-date": dateEnv.formatIso(date, {
        omitTimeZoneOffset: true,
        omitTime: !tDateProfile.isTimeScale
      })
    }, renderProps, generatorName: "slotLaneContent", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount }, (InnerContent) => y(InnerContent, { elTag: "div" }));
  }
};
var TimelineSlatsBody = class extends BaseComponent {
  render() {
    let { props } = this;
    let { tDateProfile, cellElRefs } = props;
    let { slotDates, isWeekStarts } = tDateProfile;
    let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;
    return y(
      "tbody",
      null,
      y("tr", null, slotDates.map((slotDate, i) => {
        let key = slotDate.toISOString();
        return y(TimelineSlatCell, { key, elRef: cellElRefs.createRef(key), date: slotDate, dateProfile: props.dateProfile, tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isEm: isWeekStarts[i], isDay });
      }))
    );
  }
};
var TimelineSlats = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.cellElRefs = new RefMap();
    this.handleScrollRequest = (request) => {
      let { onScrollLeftRequest } = this.props;
      let { coords } = this;
      if (onScrollLeftRequest && coords) {
        if (request.time) {
          let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));
          onScrollLeftRequest(scrollLeft);
        }
        return true;
      }
      return null;
    };
  }
  render() {
    let { props, context } = this;
    return y(
      "div",
      { className: "fc-timeline-slots", ref: this.rootElRef },
      y(
        "table",
        { "aria-hidden": true, className: context.theme.getClass("table"), style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth
        } },
        props.tableColGroupNode,
        y(TimelineSlatsBody, { cellElRefs: this.cellElRefs, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange })
      )
    );
  }
  componentDidMount() {
    this.updateSizing();
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  }
  componentDidUpdate(prevProps) {
    this.updateSizing();
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
  }
  componentWillUnmount() {
    this.scrollResponder.detach();
    if (this.props.onCoords) {
      this.props.onCoords(null);
    }
  }
  updateSizing() {
    let { props, context } = this;
    if (props.clientWidth !== null && // is sizing stable?
    this.scrollResponder) {
      let rootEl = this.rootElRef.current;
      if (rootEl.offsetWidth) {
        this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);
        if (props.onCoords) {
          props.onCoords(this.coords);
        }
        this.scrollResponder.update(false);
      }
    }
  }
  positionToHit(leftPosition) {
    let { outerCoordCache } = this.coords;
    let { dateEnv, isRtl } = this.context;
    let { tDateProfile } = this.props;
    let slatIndex = outerCoordCache.leftToIndex(leftPosition);
    if (slatIndex != null) {
      let slatWidth = outerCoordCache.getWidth(slatIndex);
      let partial = isRtl ? (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth : (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;
      let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);
      let start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));
      let end = dateEnv.add(start, tDateProfile.snapDuration);
      return {
        dateSpan: {
          range: { start, end },
          allDay: !this.props.tDateProfile.isTimeScale
        },
        dayEl: this.cellElRefs.currentMap[slatIndex],
        left: outerCoordCache.lefts[slatIndex],
        right: outerCoordCache.rights[slatIndex]
      };
    }
    return null;
  }
};
function collectCellEls(elMap, slotDates) {
  return slotDates.map((slotDate) => {
    let key = slotDate.toISOString();
    return elMap[key];
  });
}
function computeSegHCoords(segs, minWidth, timelineCoords) {
  let hcoords = [];
  if (timelineCoords) {
    for (let seg of segs) {
      let res = timelineCoords.rangeToCoords(seg);
      let start = Math.round(res.start);
      let end = Math.round(res.end);
      if (end - start < minWidth) {
        end = start + minWidth;
      }
      hcoords.push({ start, end });
    }
  }
  return hcoords;
}
function computeFgSegPlacements(segs, segHCoords, eventInstanceHeights, moreLinkHeights, strictOrder, maxStackCnt) {
  let segInputs = [];
  let crudePlacements = [];
  for (let i = 0; i < segs.length; i += 1) {
    let seg = segs[i];
    let instanceId = seg.eventRange.instance.instanceId;
    let height = eventInstanceHeights[instanceId];
    let hcoords = segHCoords[i];
    if (height && hcoords) {
      segInputs.push({
        index: i,
        span: hcoords,
        thickness: height
      });
    } else {
      crudePlacements.push({
        seg,
        hcoords,
        top: null
      });
    }
  }
  let hierarchy = new SegHierarchy();
  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }
  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let hiddenPlacements = hiddenEntries.map((entry) => ({
    seg: segs[entry.index],
    hcoords: entry.span,
    top: null
  }));
  let hiddenGroups = groupIntersectingEntries(hiddenEntries);
  let moreLinkInputs = [];
  let moreLinkCrudePlacements = [];
  const extractSeg = (entry) => segs[entry.index];
  for (let i = 0; i < hiddenGroups.length; i += 1) {
    let hiddenGroup = hiddenGroups[i];
    let sortedSegs = hiddenGroup.entries.map(extractSeg);
    let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))];
    if (height != null) {
      moreLinkInputs.push({
        index: segs.length + i,
        thickness: height,
        span: hiddenGroup.span
      });
    } else {
      moreLinkCrudePlacements.push({
        seg: sortedSegs,
        hcoords: hiddenGroup.span,
        top: null
      });
    }
  }
  hierarchy.maxStackCnt = -1;
  hierarchy.addSegs(moreLinkInputs);
  let visibleRects = hierarchy.toRects();
  let visiblePlacements = [];
  let maxHeight = 0;
  for (let rect of visibleRects) {
    let segIndex = rect.index;
    visiblePlacements.push({
      seg: segIndex < segs.length ? segs[segIndex] : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),
      hcoords: rect.span,
      top: rect.levelCoord
    });
    maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);
  }
  return [
    visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements),
    maxHeight
  ];
}
var TimelineLaneBg = class extends BaseComponent {
  render() {
    let { props } = this;
    let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);
    return props.timelineCoords && y(
      "div",
      { className: "fc-timeline-bg" },
      this.renderSegs(props.businessHourSegs || [], props.timelineCoords, "non-business"),
      this.renderSegs(props.bgEventSegs || [], props.timelineCoords, "bg-event"),
      this.renderSegs(highlightSeg, props.timelineCoords, "highlight")
    );
  }
  renderSegs(segs, timelineCoords, fillType) {
    let { todayRange, nowDate } = this.props;
    let { isRtl } = this.context;
    let segHCoords = computeSegHCoords(segs, 0, timelineCoords);
    let children = segs.map((seg, i) => {
      let hcoords = segHCoords[i];
      let hStyle = coordsToCss(hcoords, isRtl);
      return y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timeline-bg-harness", style: hStyle }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange, nowDate))) : renderFill(fillType));
    });
    return y(_, null, children);
  }
};
var TimelineLaneSlicer = class extends Slicer {
  sliceRange(origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {
    let normalRange = normalizeRange(origRange, tDateProfile, dateEnv);
    let segs = [];
    if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv) < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {
      let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);
      if (slicedRange) {
        segs.push({
          start: slicedRange.start,
          end: slicedRange.end,
          isStart: slicedRange.start.valueOf() === normalRange.start.valueOf() && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),
          isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf() && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator)
        });
      }
    }
    return segs;
  }
};
var DEFAULT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
var TimelineEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-timeline-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TIME_FORMAT, defaultDisplayEventTime: !props.isTimeScale }));
  }
};
var TimelineLaneMoreLink = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { hiddenSegs, placement, resourceId } = props;
    let { top, hcoords } = placement;
    let isVisible = hcoords && top !== null;
    let hStyle = coordsToCss(hcoords, context.isRtl);
    let extraDateSpan = resourceId ? { resourceId } : {};
    return y(MoreLinkContainer, { elRef: props.elRef, elClasses: ["fc-timeline-more-link"], elStyle: Object.assign({ visibility: isVisible ? "" : "hidden", top: top || 0 }, hStyle), allDayDate: null, moreCnt: hiddenSegs.length, allSegs: hiddenSegs, hiddenSegs, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan, popoverContent: () => y(_, null, hiddenSegs.map((seg) => {
      let instanceId = seg.eventRange.instance.instanceId;
      return y(
        "div",
        { key: instanceId, style: { visibility: props.isForcedInvisible[instanceId] ? "hidden" : "" } },
        y(TimelineEvent, Object.assign({ isTimeScale: props.isTimeScale, seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection }, getSegMeta(seg, props.todayRange, props.nowDate)))
      );
    })) }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-timeline-more-link-inner", "fc-sticky"] }));
  }
};
var TimelineLane = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.slicer = new TimelineLaneSlicer();
    this.sortEventSegs = memoize(sortEventSegs);
    this.harnessElRefs = new RefMap();
    this.moreElRefs = new RefMap();
    this.innerElRef = d();
    this.state = {
      eventInstanceHeights: {},
      moreLinkHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSize();
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let { dateProfile, tDateProfile } = props;
    let slicedProps = this.slicer.sliceProps(
      props,
      dateProfile,
      tDateProfile.isTimeScale ? null : props.nextDayThreshold,
      context,
      // wish we didn't have to pass in the rest of the args...
      dateProfile,
      context.dateProfileGenerator,
      tDateProfile,
      context.dateEnv
    );
    let mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) || (slicedProps.eventResize ? slicedProps.eventResize.segs : null) || [];
    let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);
    let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);
    let [fgPlacements, fgHeight] = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack);
    let isForcedInvisible = (
      // TODO: more convenient
      (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) || (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) || {}
    );
    return y(
      _,
      null,
      y(TimelineLaneBg, { businessHourSegs: slicedProps.businessHourSegs, bgEventSegs: slicedProps.bgEventSegs, timelineCoords: props.timelineCoords, eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : [], dateSelectionSegs: slicedProps.dateSelectionSegs, nowDate: props.nowDate, todayRange: props.todayRange }),
      y(
        "div",
        { className: "fc-timeline-events fc-scrollgrid-sync-inner", ref: this.innerElRef, style: { height: fgHeight } },
        this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false),
        this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false)
      )
    );
  }
  componentDidMount() {
    this.updateSize();
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.eventStore !== this.props.eventStore || // external thing changed?
    prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?
    prevState.moreLinkHeights !== this.state.moreLinkHeights) {
      this.updateSize();
    }
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateSize() {
    let { props } = this;
    let { timelineCoords } = props;
    const innerEl = this.innerElRef.current;
    if (props.onHeightChange) {
      props.onHeightChange(innerEl, false);
    }
    if (timelineCoords) {
      this.setState({
        eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, (harnessEl) => Math.round(harnessEl.getBoundingClientRect().height)),
        moreLinkHeights: mapHash(this.moreElRefs.currentMap, (moreEl) => Math.round(moreEl.getBoundingClientRect().height))
      }, () => {
        if (props.onHeightChange) {
          props.onHeightChange(innerEl, true);
        }
      });
    }
    if (props.syncParentMinHeight) {
      innerEl.parentElement.style.minHeight = innerEl.style.height;
    }
  }
  renderFgSegs(segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { harnessElRefs, moreElRefs, props, context } = this;
    let isMirror = isDragging || isResizing || isDateSelecting;
    return y(_, null, segPlacements.map((segPlacement) => {
      let { seg, hcoords, top } = segPlacement;
      if (Array.isArray(seg)) {
        let isoStr = buildIsoString(computeEarliestSegStart(seg));
        return y(TimelineLaneMoreLink, { key: "m:" + isoStr, elRef: moreElRefs.createRef(isoStr), hiddenSegs: seg, placement: segPlacement, dateProfile: props.dateProfile, nowDate: props.nowDate, todayRange: props.todayRange, isTimeScale: props.tDateProfile.isTimeScale, eventSelection: props.eventSelection, resourceId: props.resourceId, isForcedInvisible });
      }
      let instanceId = seg.eventRange.instance.instanceId;
      let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);
      let hStyle = coordsToCss(hcoords, context.isRtl);
      return y(
        "div",
        { key: "e:" + instanceId, ref: isMirror ? null : harnessElRefs.createRef(instanceId), className: "fc-timeline-event-harness", style: Object.assign({ visibility: isVisible ? "" : "hidden", top: top || 0 }, hStyle) },
        y(TimelineEvent, Object.assign({
          isTimeScale: props.tDateProfile.isTimeScale,
          seg,
          isDragging,
          isResizing,
          isDateSelecting,
          isSelected: instanceId === props.eventSelection
          /* TODO: bad for mirror? */
        }, getSegMeta(seg, props.todayRange, props.nowDate)))
      );
    }));
  }
};
TimelineLane.addStateEquality({
  eventInstanceHeights: isPropsEqual,
  moreLinkHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {
  if (!mirrorSegs.length || !timelineCoords) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(fgPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    hcoords: timelineCoords.rangeToCoords(seg),
    top: topsByInstanceId[seg.eventRange.instance.instanceId]
  }));
}
function buildAbsoluteTopHash(placements) {
  let topsByInstanceId = {};
  for (let placement of placements) {
    let { seg } = placement;
    if (!Array.isArray(seg)) {
      topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;
    }
  }
  return topsByInstanceId;
}
var TimelineGrid = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.slatsRef = d();
    this.state = {
      coords: null
    };
    this.handeEl = (el) => {
      if (el) {
        this.context.registerInteractiveComponent(this, { el });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
    this.handleCoords = (coords) => {
      this.setState({ coords });
      if (this.props.onSlatCoords) {
        this.props.onSlatCoords(coords);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let { dateProfile, tDateProfile } = props;
    let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;
    return y(
      "div",
      { className: "fc-timeline-body", ref: this.handeEl, style: {
        minWidth: props.tableMinWidth,
        height: props.clientHeight,
        width: props.clientWidth
      } },
      y(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => y(
        _,
        null,
        y(TimelineSlats, { ref: this.slatsRef, dateProfile, tDateProfile, nowDate, todayRange, clientWidth: props.clientWidth, tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, onCoords: this.handleCoords, onScrollLeftRequest: props.onScrollLeftRequest }),
        y(TimelineLane, { dateProfile, tDateProfile: props.tDateProfile, nowDate, todayRange, nextDayThreshold: options.nextDayThreshold, businessHours: props.businessHours, eventStore: props.eventStore, eventUiBases: props.eventUiBases, dateSelection: props.dateSelection, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, timelineCoords: state.coords, syncParentMinHeight: true }),
        options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate) && y(
          "div",
          { className: "fc-timeline-now-indicator-container" },
          y(NowIndicatorContainer, { elClasses: ["fc-timeline-now-indicator-line"], elStyle: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl), isAxis: false, date: nowDate })
        )
      ))
    );
  }
  // Hit System
  // ------------------------------------------------------------------------------------------
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let slats = this.slatsRef.current;
    let slatHit = slats.positionToHit(positionLeft);
    if (slatHit) {
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: slatHit.dateSpan,
        rect: {
          left: slatHit.left,
          right: slatHit.right,
          top: 0,
          bottom: elHeight
        },
        dayEl: slatHit.dayEl,
        layer: 0
      };
    }
    return null;
  }
};
var TimelineView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);
    this.scrollGridRef = d();
    this.state = {
      slatCoords: null,
      slotCushionMaxWidth: null
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
    };
    this.handleScrollLeftRequest = (scrollLeft) => {
      let scrollGrid = this.scrollGridRef.current;
      scrollGrid.forceScrollLeft(0, scrollLeft);
    };
    this.handleMaxCushionWidth = (slotCushionMaxWidth) => {
      this.setState({
        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth)
        // for less rerendering TODO: DRY
      });
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);
    let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);
    let { slotMinWidth } = options;
    let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));
    let sections = [
      {
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "timeline",
          content: (contentArg) => y(TimelineHeader, { dateProfile: props.dateProfile, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile, slatCoords: state.slatCoords, onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth })
        }]
      },
      {
        type: "body",
        key: "body",
        liquid: true,
        chunks: [{
          key: "timeline",
          content: (contentArg) => y(TimelineGrid, Object.assign({}, props, { clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, tDateProfile, onSlatCoords: this.handleSlatCoords, onScrollLeftRequest: this.handleScrollLeftRequest }))
        }]
      }
    ];
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "timeline",
          content: renderScrollShim
        }]
      });
    }
    return y(
      ViewContainer,
      { elClasses: [
        "fc-timeline",
        options.eventOverlap === false ? "fc-timeline-overlap-disabled" : ""
      ], viewSpec: context.viewSpec },
      y(ScrollGrid, { ref: this.scrollGridRef, liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
        { cols: slatCols }
      ], sections })
    );
  }
  computeFallbackSlotMinWidth(tDateProfile) {
    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);
  }
};
function buildSlatCols(tDateProfile, slotMinWidth) {
  return [{
    span: tDateProfile.slotCnt,
    minWidth: slotMinWidth || 1
    // needs to be a non-zero number to trigger horizontal scrollbars!??????
  }];
}
var css_248z = '.fc .fc-timeline-body{min-height:100%;position:relative;z-index:1}.fc .fc-timeline-slots{bottom:0;position:absolute;top:0;z-index:1}.fc .fc-timeline-slots>table{height:100%}.fc .fc-timeline-slot-minor{border-style:dotted}.fc .fc-timeline-slot-frame{align-items:center;display:flex;justify-content:center}.fc .fc-timeline-header-row-chrono .fc-timeline-slot-frame{justify-content:flex-start}.fc .fc-timeline-header-row:last-child .fc-timeline-slot-frame{overflow:hidden}.fc .fc-timeline-slot-cushion{padding:4px 5px;white-space:nowrap}.fc-direction-ltr .fc-timeline-slot{border-right:0!important}.fc-direction-rtl .fc-timeline-slot{border-left:0!important}.fc .fc-timeline-now-indicator-container{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:4}.fc .fc-timeline-now-indicator-arrow,.fc .fc-timeline-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;pointer-events:none;position:absolute;top:0}.fc .fc-timeline-now-indicator-arrow{border-left-color:transparent;border-right-color:transparent;border-width:6px 5px 0;margin:0 -6px}.fc .fc-timeline-now-indicator-line{border-width:0 0 0 1px;bottom:0;margin:0 -1px}.fc .fc-timeline-events{position:relative;width:0;z-index:3}.fc .fc-timeline-event-harness,.fc .fc-timeline-more-link{position:absolute;top:0}.fc-timeline-event{z-index:1}.fc-timeline-event.fc-event-mirror{z-index:2}.fc-timeline-event{align-items:center;border-radius:0;display:flex;font-size:var(--fc-small-font-size);margin-bottom:1px;padding:2px 1px;position:relative}.fc-timeline-event .fc-event-main{flex-grow:1;flex-shrink:1;min-width:0}.fc-timeline-event .fc-event-time{font-weight:700}.fc-timeline-event .fc-event-time,.fc-timeline-event .fc-event-title{padding:0 2px;white-space:nowrap}.fc-direction-ltr .fc-timeline-event.fc-event-end,.fc-direction-ltr .fc-timeline-more-link{margin-right:1px}.fc-direction-rtl .fc-timeline-event.fc-event-end,.fc-direction-rtl .fc-timeline-more-link{margin-left:1px}.fc-timeline-overlap-disabled .fc-timeline-event{margin-bottom:0;padding-bottom:5px;padding-top:5px}.fc-timeline-event:not(.fc-event-end):after,.fc-timeline-event:not(.fc-event-start):before{border-color:transparent #000;border-style:solid;border-width:5px;content:"";flex-grow:0;flex-shrink:0;height:0;margin:0 1px;opacity:.5;width:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-start):before,.fc-direction-rtl .fc-timeline-event:not(.fc-event-end):after{border-left:0}.fc-direction-ltr .fc-timeline-event:not(.fc-event-end):after,.fc-direction-rtl .fc-timeline-event:not(.fc-event-start):before{border-right:0}.fc-timeline-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;font-size:var(--fc-small-font-size);padding:1px}.fc-timeline-more-link-inner{display:inline-block;left:0;padding:2px;right:0}.fc .fc-timeline-bg{bottom:0;left:0;position:absolute;right:0;top:0;width:0;z-index:2}.fc .fc-timeline-bg .fc-non-business{z-index:1}.fc .fc-timeline-bg .fc-bg-event{z-index:2}.fc .fc-timeline-bg .fc-highlight{z-index:3}.fc .fc-timeline-bg-harness{bottom:0;position:absolute;top:0}';
injectStyles(css_248z);

// node_modules/@fullcalendar/timeline/index.js
var index3 = createPlugin({
  name: "@fullcalendar/timeline",
  premiumReleaseDate: "2024-07-12",
  deps: [index],
  initialView: "timelineDay",
  views: {
    timeline: {
      component: TimelineView,
      usesMinMaxTime: true,
      eventResizableFromStart: true
      // how is this consumed for TimelineView tho?
    },
    timelineDay: {
      type: "timeline",
      duration: { days: 1 }
    },
    timelineWeek: {
      type: "timeline",
      duration: { weeks: 1 }
    },
    timelineMonth: {
      type: "timeline",
      duration: { months: 1 }
    },
    timelineYear: {
      type: "timeline",
      duration: { years: 1 }
    }
  }
});

// node_modules/@fullcalendar/resource-timeline/internal.js
function ExpanderIcon({ depth, hasChildren, isExpanded, onExpanderClick }) {
  let nodes = [];
  for (let i = 0; i < depth; i += 1) {
    nodes.push(y("span", { className: "fc-icon" }));
  }
  let iconClassNames = ["fc-icon"];
  if (hasChildren) {
    if (isExpanded) {
      iconClassNames.push("fc-icon-minus-square");
    } else {
      iconClassNames.push("fc-icon-plus-square");
    }
  }
  nodes.push(y(
    "span",
    { className: "fc-datagrid-expander" + (hasChildren ? "" : " fc-datagrid-expander-placeholder"), onClick: onExpanderClick },
    y("span", { className: iconClassNames.join(" ") })
  ));
  return y(_, {}, ...nodes);
}
var SpreadsheetIndividualCell = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps2);
    this.onExpanderClick = (ev) => {
      let { props } = this;
      if (props.hasChildren) {
        this.context.dispatch({
          type: "SET_RESOURCE_ENTITY_EXPANDED",
          id: props.resource.id,
          isExpanded: !props.isExpanded
        });
      }
    };
  }
  render() {
    let { props, context } = this;
    let { colSpec } = props;
    let renderProps = this.refineRenderProps({
      resource: props.resource,
      fieldValue: props.fieldValue,
      context
    });
    return y(ContentContainer, { elTag: "td", elClasses: [
      "fc-datagrid-cell",
      "fc-resource"
    ], elAttrs: {
      role: "gridcell",
      "data-resource-id": props.resource.id
    }, renderProps, generatorName: colSpec.isMain ? "resourceLabelContent" : void 0, customGenerator: colSpec.cellContent, defaultGenerator: renderResourceInner, classNameGenerator: colSpec.cellClassNames, didMount: colSpec.cellDidMount, willUnmount: colSpec.cellWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-datagrid-cell-frame", style: { height: props.innerHeight } },
      y(
        "div",
        { className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner" },
        colSpec.isMain && y(ExpanderIcon, { depth: props.depth, hasChildren: props.hasChildren, isExpanded: props.isExpanded, onExpanderClick: this.onExpanderClick }),
        y(InnerContent, { elTag: "span", elClasses: ["fc-datagrid-cell-main"] })
      )
    ));
  }
};
function renderResourceInner(renderProps) {
  return renderProps.fieldValue || y(_, null, " ");
}
function refineRenderProps2(input) {
  return {
    resource: new ResourceApi(input.context, input.resource),
    fieldValue: input.fieldValue,
    view: input.context.viewApi
  };
}
var SpreadsheetGroupCell = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { colSpec } = props;
    let renderProps = {
      groupValue: props.fieldValue,
      view: context.viewApi
    };
    return y(ContentContainer, { elTag: "td", elClasses: [
      "fc-datagrid-cell",
      "fc-resource-group"
    ], elAttrs: {
      role: "gridcell",
      rowSpan: props.rowSpan
    }, renderProps, generatorName: "resourceGroupLabelContent", customGenerator: colSpec.cellContent, defaultGenerator: renderGroupInner, classNameGenerator: colSpec.cellClassNames, didMount: colSpec.cellDidMount, willUnmount: colSpec.cellWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-datagrid-cell-frame fc-datagrid-cell-frame-liquid" },
      y(InnerContent, { elTag: "div", elClasses: ["fc-datagrid-cell-cushion", "fc-sticky"] })
    ));
  }
};
function renderGroupInner(renderProps) {
  return renderProps.groupValue || y(_, null, " ");
}
var SpreadsheetRow = class extends BaseComponent {
  render() {
    let { props } = this;
    let { resource, rowSpans, depth } = props;
    let resourceFields = buildResourceFields(resource);
    return y("tr", { role: "row" }, props.colSpecs.map((colSpec, i) => {
      let rowSpan = rowSpans[i];
      if (rowSpan === 0) {
        return null;
      }
      if (rowSpan == null) {
        rowSpan = 1;
      }
      let fieldValue = colSpec.field ? resourceFields[colSpec.field] : resource.title || getPublicId(resource.id);
      if (rowSpan > 1) {
        return y(SpreadsheetGroupCell, { key: i, colSpec, fieldValue, rowSpan });
      }
      return y(SpreadsheetIndividualCell, { key: i, colSpec, resource, fieldValue, depth, hasChildren: props.hasChildren, isExpanded: props.isExpanded, innerHeight: props.innerHeight });
    }));
  }
};
SpreadsheetRow.addPropsEquality({
  rowSpans: isArraysEqual
});
var SpreadsheetGroupRow = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.innerInnerRef = d();
    this.onExpanderClick = () => {
      let { props } = this;
      this.context.dispatch({
        type: "SET_RESOURCE_ENTITY_EXPANDED",
        id: props.id,
        isExpanded: !props.isExpanded
      });
    };
  }
  render() {
    let { props, context } = this;
    let renderProps = { groupValue: props.group.value, view: context.viewApi };
    let spec = props.group.spec;
    return y(
      "tr",
      { role: "row" },
      y(ContentContainer, { elTag: "th", elClasses: [
        "fc-datagrid-cell",
        "fc-resource-group",
        context.theme.getClass("tableCellShaded")
      ], elAttrs: {
        // ARIA TODO: not really a columnheader
        // extremely tedious to make this aria-compliant,
        // to assign multiple headers to each cell
        // https://www.w3.org/WAI/tutorials/tables/multi-level/
        role: "columnheader",
        scope: "colgroup",
        colSpan: props.spreadsheetColCnt
      }, renderProps, generatorName: "resourceGroupLabelContent", customGenerator: spec.labelContent, defaultGenerator: renderCellInner, classNameGenerator: spec.labelClassNames, didMount: spec.labelDidMount, willUnmount: spec.labelWillUnmount }, (InnerContent) => y(
        "div",
        { className: "fc-datagrid-cell-frame", style: { height: props.innerHeight } },
        y(
          "div",
          { className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner", ref: this.innerInnerRef },
          y(ExpanderIcon, { depth: 0, hasChildren: true, isExpanded: props.isExpanded, onExpanderClick: this.onExpanderClick }),
          y(InnerContent, { elTag: "span", elClasses: ["fc-datagrid-cell-main"] })
        )
      ))
    );
  }
};
SpreadsheetGroupRow.addPropsEquality({
  group: isGroupsEqual
});
function renderCellInner(renderProps) {
  return renderProps.groupValue || y(_, null, " ");
}
var SPREADSHEET_COL_MIN_WIDTH = 20;
var SpreadsheetHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.resizerElRefs = new RefMap(this._handleColResizerEl.bind(this));
    this.colDraggings = {};
  }
  render() {
    let { colSpecs, superHeaderRendering, rowInnerHeights } = this.props;
    let renderProps = { view: this.context.viewApi };
    let rowNodes = [];
    rowInnerHeights = rowInnerHeights.slice();
    if (superHeaderRendering) {
      let rowInnerHeight2 = rowInnerHeights.shift();
      rowNodes.push(y(
        "tr",
        { key: "row-super", role: "row" },
        y(ContentContainer, { elTag: "th", elClasses: [
          "fc-datagrid-cell",
          "fc-datagrid-cell-super"
        ], elAttrs: {
          role: "columnheader",
          scope: "colgroup",
          colSpan: colSpecs.length
        }, renderProps, generatorName: "resourceAreaHeaderContent", customGenerator: superHeaderRendering.headerContent, defaultGenerator: superHeaderRendering.headerDefault, classNameGenerator: superHeaderRendering.headerClassNames, didMount: superHeaderRendering.headerDidMount, willUnmount: superHeaderRendering.headerWillUnmount }, (InnerContent) => y(
          "div",
          { className: "fc-datagrid-cell-frame", style: { height: rowInnerHeight2 } },
          y(InnerContent, { elTag: "div", elClasses: ["fc-datagrid-cell-cushion", "fc-scrollgrid-sync-inner"] })
        ))
      ));
    }
    let rowInnerHeight = rowInnerHeights.shift();
    rowNodes.push(y("tr", { key: "row", role: "row" }, colSpecs.map((colSpec, i) => {
      let isLastCol = i === colSpecs.length - 1;
      return y(ContentContainer, { key: i, elTag: "th", elClasses: ["fc-datagrid-cell"], elAttrs: { role: "columnheader" }, renderProps, generatorName: "resourceAreaHeaderContent", customGenerator: colSpec.headerContent, defaultGenerator: colSpec.headerDefault, classNameGenerator: colSpec.headerClassNames, didMount: colSpec.headerDidMount, willUnmount: colSpec.headerWillUnmount }, (InnerContent) => y(
        "div",
        { className: "fc-datagrid-cell-frame", style: { height: rowInnerHeight } },
        y(
          "div",
          { className: "fc-datagrid-cell-cushion fc-scrollgrid-sync-inner" },
          colSpec.isMain && y(
            "span",
            { className: "fc-datagrid-expander fc-datagrid-expander-placeholder" },
            y("span", { className: "fc-icon" })
          ),
          y(InnerContent, { elTag: "span", elClasses: ["fc-datagrid-cell-main"] })
        ),
        !isLastCol && y("div", { className: "fc-datagrid-cell-resizer", ref: this.resizerElRefs.createRef(i) })
      ));
    })));
    return y(_, null, rowNodes);
  }
  _handleColResizerEl(resizerEl, index5) {
    let { colDraggings } = this;
    if (!resizerEl) {
      let dragging = colDraggings[index5];
      if (dragging) {
        dragging.destroy();
        delete colDraggings[index5];
      }
    } else {
      let dragging = this.initColResizing(resizerEl, parseInt(index5, 10));
      if (dragging) {
        colDraggings[index5] = dragging;
      }
    }
  }
  initColResizing(resizerEl, index5) {
    let { pluginHooks, isRtl } = this.context;
    let { onColWidthChange } = this.props;
    let ElementDraggingImpl = pluginHooks.elementDraggingImpl;
    if (ElementDraggingImpl) {
      let dragging = new ElementDraggingImpl(resizerEl);
      let startWidth;
      let currentWidths;
      dragging.emitter.on("dragstart", () => {
        let allCells = findElements(elementClosest(resizerEl, "tr"), "th");
        currentWidths = allCells.map((cellEl) => cellEl.getBoundingClientRect().width);
        startWidth = currentWidths[index5];
      });
      dragging.emitter.on("dragmove", (pev) => {
        currentWidths[index5] = Math.max(startWidth + pev.deltaX * (isRtl ? -1 : 1), SPREADSHEET_COL_MIN_WIDTH);
        if (onColWidthChange) {
          onColWidthChange(currentWidths.slice());
        }
      });
      dragging.setAutoScrollEnabled(false);
      return dragging;
    }
    return null;
  }
};
var ResourceTimelineLane = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps$1);
    this.handleHeightChange = (innerEl, isStable) => {
      if (this.props.onHeightChange) {
        this.props.onHeightChange(
          // would want to use own <tr> ref, but not guaranteed to be ready when this fires
          elementClosest(innerEl, "tr"),
          isStable
        );
      }
    };
  }
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = this.refineRenderProps({ resource: props.resource, context });
    return y(
      "tr",
      { ref: props.elRef },
      y(ContentContainer, { elTag: "td", elClasses: [
        "fc-timeline-lane",
        "fc-resource"
      ], elAttrs: {
        "data-resource-id": props.resource.id
      }, renderProps, generatorName: "resourceLaneContent", customGenerator: options.resourceLaneContent, classNameGenerator: options.resourceLaneClassNames, didMount: options.resourceLaneDidMount, willUnmount: options.resourceLaneWillUnmount }, (InnerContent) => y(
        "div",
        { className: "fc-timeline-lane-frame", style: { height: props.innerHeight } },
        y(InnerContent, { elTag: "div", elClasses: ["fc-timeline-lane-misc"] }),
        y(TimelineLane, { dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, nextDayThreshold: props.nextDayThreshold, businessHours: props.businessHours, eventStore: props.eventStore, eventUiBases: props.eventUiBases, dateSelection: props.dateSelection, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, timelineCoords: props.timelineCoords, onHeightChange: this.handleHeightChange, resourceId: props.resource.id })
      ))
    );
  }
};
var DividerRow = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { renderHooks } = props;
    let renderProps = {
      groupValue: props.groupValue,
      view: context.viewApi
    };
    return y(
      "tr",
      { ref: props.elRef },
      y(ContentContainer, { elTag: "td", elRef: props.elRef, elClasses: [
        "fc-timeline-lane",
        "fc-resource-group",
        context.theme.getClass("tableCellShaded")
      ], renderProps, generatorName: "resourceGroupLaneContent", customGenerator: renderHooks.laneContent, classNameGenerator: renderHooks.laneClassNames, didMount: renderHooks.laneDidMount, willUnmount: renderHooks.laneWillUnmount }, (InnerContainer) => y(InnerContainer, { elTag: "div", elStyle: { height: props.innerHeight } }))
    );
  }
};
var ResourceTimelineLanesBody = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { rowElRefs, innerHeights } = props;
    return y("tbody", null, props.rowNodes.map((node, index5) => {
      if (node.group) {
        return y(DividerRow, { key: node.id, elRef: rowElRefs.createRef(node.id), groupValue: node.group.value, renderHooks: node.group.spec, innerHeight: innerHeights[index5] || "" });
      }
      if (node.resource) {
        let resource = node.resource;
        return y(ResourceTimelineLane, Object.assign({ key: node.id, elRef: rowElRefs.createRef(node.id) }, props.splitProps[resource.id], { resource, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, nextDayThreshold: context.options.nextDayThreshold, businessHours: resource.businessHours || props.fallbackBusinessHours, innerHeight: innerHeights[index5] || "", timelineCoords: props.slatCoords, onHeightChange: props.onRowHeightChange }));
      }
      return null;
    }));
  }
};
var ResourceTimelineLanes = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.rowElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    return y(
      "table",
      { ref: this.rootElRef, "aria-hidden": true, className: "fc-scrollgrid-sync-table " + context.theme.getClass("table"), style: {
        minWidth: props.tableMinWidth,
        width: props.clientWidth,
        height: props.minHeight
      } },
      y(ResourceTimelineLanesBody, { rowElRefs: this.rowElRefs, rowNodes: props.rowNodes, dateProfile: props.dateProfile, tDateProfile: props.tDateProfile, nowDate: props.nowDate, todayRange: props.todayRange, splitProps: props.splitProps, fallbackBusinessHours: props.fallbackBusinessHours, slatCoords: props.slatCoords, innerHeights: props.innerHeights, onRowHeightChange: props.onRowHeightChange })
    );
  }
  componentDidMount() {
    this.updateCoords();
  }
  componentDidUpdate() {
    this.updateCoords();
  }
  componentWillUnmount() {
    if (this.props.onRowCoords) {
      this.props.onRowCoords(null);
    }
  }
  updateCoords() {
    let { props } = this;
    if (props.onRowCoords && props.clientWidth !== null) {
      this.props.onRowCoords(new PositionCache(this.rootElRef.current, collectRowEls(this.rowElRefs.currentMap, props.rowNodes), false, true));
    }
  }
};
function collectRowEls(elMap, rowNodes) {
  return rowNodes.map((rowNode) => elMap[rowNode.id]);
}
var ResourceTimelineGrid = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.computeHasResourceBusinessHours = memoize(computeHasResourceBusinessHours);
    this.resourceSplitter = new ResourceSplitter();
    this.bgSlicer = new TimelineLaneSlicer();
    this.slatsRef = d();
    this.state = {
      slatCoords: null
    };
    this.handleEl = (el) => {
      if (el) {
        this.context.registerInteractiveComponent(this, { el });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
      if (this.props.onSlatCoords) {
        this.props.onSlatCoords(slatCoords);
      }
    };
    this.handleRowCoords = (rowCoords) => {
      this.rowCoords = rowCoords;
      if (this.props.onRowCoords) {
        this.props.onRowCoords(rowCoords);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { dateProfile, tDateProfile } = props;
    let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;
    let hasResourceBusinessHours = this.computeHasResourceBusinessHours(props.rowNodes);
    let splitProps = this.resourceSplitter.splitProps(props);
    let bgLaneProps = splitProps[""];
    let bgSlicedProps = this.bgSlicer.sliceProps(
      bgLaneProps,
      dateProfile,
      tDateProfile.isTimeScale ? null : props.nextDayThreshold,
      context,
      // wish we didn't need to pass in the rest of these args...
      dateProfile,
      context.dateProfileGenerator,
      tDateProfile,
      context.dateEnv
    );
    let slatCoords = state.slatCoords && state.slatCoords.dateProfile === props.dateProfile ? state.slatCoords : null;
    return y(
      "div",
      { ref: this.handleEl, className: [
        "fc-timeline-body",
        props.expandRows ? "fc-timeline-body-expandrows" : ""
      ].join(" "), style: { minWidth: props.tableMinWidth } },
      y(NowTimer, { unit: timerUnit }, (nowDate, todayRange) => y(
        _,
        null,
        y(TimelineSlats, { ref: this.slatsRef, dateProfile, tDateProfile, nowDate, todayRange, clientWidth: props.clientWidth, tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, onCoords: this.handleSlatCoords, onScrollLeftRequest: props.onScrollLeftRequest }),
        y(TimelineLaneBg, {
          businessHourSegs: hasResourceBusinessHours ? null : bgSlicedProps.businessHourSegs,
          bgEventSegs: bgSlicedProps.bgEventSegs,
          timelineCoords: slatCoords,
          // empty array will result in unnecessary rerenders?
          eventResizeSegs: bgSlicedProps.eventResize ? bgSlicedProps.eventResize.segs : [],
          dateSelectionSegs: bgSlicedProps.dateSelectionSegs,
          nowDate,
          todayRange
        }),
        y(ResourceTimelineLanes, { rowNodes: props.rowNodes, dateProfile, tDateProfile: props.tDateProfile, nowDate, todayRange, splitProps, fallbackBusinessHours: hasResourceBusinessHours ? props.businessHours : null, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : "", tableMinWidth: props.tableMinWidth, innerHeights: props.rowInnerHeights, slatCoords, onRowCoords: this.handleRowCoords, onRowHeightChange: props.onRowHeightChange }),
        context.options.nowIndicator && slatCoords && slatCoords.isDateInRange(nowDate) && y(
          "div",
          { className: "fc-timeline-now-indicator-container" },
          y(NowIndicatorContainer, { elClasses: ["fc-timeline-now-indicator-line"], elStyle: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl), isAxis: false, date: nowDate })
        )
      ))
    );
  }
  // Hit System
  // ------------------------------------------------------------------------------------------
  queryHit(positionLeft, positionTop) {
    let rowCoords = this.rowCoords;
    let rowIndex = rowCoords.topToIndex(positionTop);
    if (rowIndex != null) {
      let resource = this.props.rowNodes[rowIndex].resource;
      if (resource) {
        let slatHit = this.slatsRef.current.positionToHit(positionLeft);
        if (slatHit) {
          return {
            dateProfile: this.props.dateProfile,
            dateSpan: {
              range: slatHit.dateSpan.range,
              allDay: slatHit.dateSpan.allDay,
              resourceId: resource.id
            },
            rect: {
              left: slatHit.left,
              right: slatHit.right,
              top: rowCoords.tops[rowIndex],
              bottom: rowCoords.bottoms[rowIndex]
            },
            dayEl: slatHit.dayEl,
            layer: 0
          };
        }
      }
    }
    return null;
  }
};
function computeHasResourceBusinessHours(rowNodes) {
  for (let node of rowNodes) {
    let resource = node.resource;
    if (resource && resource.businessHours) {
      return true;
    }
  }
  return false;
}
var MIN_RESOURCE_AREA_WIDTH = 30;
var ResourceTimelineViewLayout = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.scrollGridRef = d();
    this.timeBodyScrollerElRef = d();
    this.spreadsheetHeaderChunkElRef = d();
    this.rootElRef = d();
    this.ensureScrollGridResizeId = 0;
    this.state = {
      resourceAreaWidthOverride: null
    };
    this.ensureScrollGridResize = () => {
      if (this.ensureScrollGridResizeId) {
        clearTimeout(this.ensureScrollGridResizeId);
      }
      this.ensureScrollGridResizeId = setTimeout(() => {
        this.scrollGridRef.current.handleSizing(false);
      }, config.SCROLLGRID_RESIZE_INTERVAL + 1);
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);
    let sections = [
      {
        type: "header",
        key: "header",
        syncRowHeights: true,
        isSticky: stickyHeaderDates,
        chunks: [
          {
            key: "datagrid",
            elRef: this.spreadsheetHeaderChunkElRef,
            // TODO: allow the content to specify this. have general-purpose 'content' with obj with keys
            tableClassName: "fc-datagrid-header",
            rowContent: props.spreadsheetHeaderRows
          },
          {
            key: "divider",
            outerContent: y("td", { role: "presentation", className: "fc-resource-timeline-divider " + context.theme.getClass("tableCellShaded") })
          },
          {
            key: "timeline",
            content: props.timeHeaderContent
          }
        ]
      },
      {
        type: "body",
        key: "body",
        syncRowHeights: true,
        liquid: true,
        expandRows: Boolean(options.expandRows),
        chunks: [
          {
            key: "datagrid",
            tableClassName: "fc-datagrid-body",
            rowContent: props.spreadsheetBodyRows
          },
          {
            key: "divider",
            outerContent: y("td", { role: "presentation", className: "fc-resource-timeline-divider " + context.theme.getClass("tableCellShaded") })
          },
          {
            key: "timeline",
            scrollerElRef: this.timeBodyScrollerElRef,
            content: props.timeBodyContent
          }
        ]
      }
    ];
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [
          {
            key: "datagrid",
            content: renderScrollShim
          },
          {
            key: "divider",
            outerContent: y("td", { role: "presentation", className: "fc-resource-timeline-divider " + context.theme.getClass("tableCellShaded") })
          },
          {
            key: "timeline",
            content: renderScrollShim
          }
        ]
      });
    }
    let resourceAreaWidth = state.resourceAreaWidthOverride != null ? state.resourceAreaWidthOverride : options.resourceAreaWidth;
    return y(ScrollGrid, { ref: this.scrollGridRef, elRef: this.rootElRef, liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
      { cols: props.spreadsheetCols, width: resourceAreaWidth },
      { cols: [] },
      { cols: props.timeCols }
    ], sections });
  }
  forceTimeScroll(left) {
    let scrollGrid = this.scrollGridRef.current;
    scrollGrid.forceScrollLeft(2, left);
  }
  forceResourceScroll(top) {
    let scrollGrid = this.scrollGridRef.current;
    scrollGrid.forceScrollTop(1, top);
  }
  getResourceScroll() {
    let timeBodyScrollerEl = this.timeBodyScrollerElRef.current;
    return timeBodyScrollerEl.scrollTop;
  }
  // Resource Area Resizing
  // ------------------------------------------------------------------------------------------
  // NOTE: a callback Ref for the resizer was firing multiple times with same elements (Preact)
  // that's why we use spreadsheetResizerElRef instead
  componentDidMount() {
    this.initSpreadsheetResizing();
  }
  componentWillUnmount() {
    this.destroySpreadsheetResizing();
  }
  initSpreadsheetResizing() {
    let { isRtl, pluginHooks } = this.context;
    let ElementDraggingImpl = pluginHooks.elementDraggingImpl;
    let spreadsheetHeadEl = this.spreadsheetHeaderChunkElRef.current;
    if (ElementDraggingImpl) {
      let rootEl = this.rootElRef.current;
      let dragging = this.spreadsheetResizerDragging = new ElementDraggingImpl(rootEl, ".fc-resource-timeline-divider");
      let dragStartWidth;
      let viewWidth;
      dragging.emitter.on("dragstart", () => {
        dragStartWidth = spreadsheetHeadEl.getBoundingClientRect().width;
        viewWidth = rootEl.getBoundingClientRect().width;
      });
      dragging.emitter.on("dragmove", (pev) => {
        let newWidth = dragStartWidth + pev.deltaX * (isRtl ? -1 : 1);
        newWidth = Math.max(newWidth, MIN_RESOURCE_AREA_WIDTH);
        newWidth = Math.min(newWidth, viewWidth - MIN_RESOURCE_AREA_WIDTH);
        this.setState({
          resourceAreaWidthOverride: newWidth
        }, this.ensureScrollGridResize);
      });
      dragging.setAutoScrollEnabled(false);
    }
  }
  destroySpreadsheetResizing() {
    if (this.spreadsheetResizerDragging) {
      this.spreadsheetResizerDragging.destroy();
    }
  }
};
var ResourceTimelineView = class extends BaseComponent {
  constructor(props, context) {
    super(props, context);
    this.processColOptions = memoize(processColOptions);
    this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);
    this.hasNesting = memoize(hasNesting);
    this.buildRowNodes = memoize(buildRowNodes);
    this.layoutRef = d();
    this.rowNodes = [];
    this.renderedRowNodes = [];
    this.buildRowIndex = memoize(buildRowIndex);
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
    };
    this.handleRowCoords = (rowCoords) => {
      this.rowCoords = rowCoords;
      this.scrollResponder.update(false);
    };
    this.handleMaxCushionWidth = (slotCushionMaxWidth) => {
      this.setState({
        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth)
        // for less rerendering TODO: DRY
      });
    };
    this.handleScrollLeftRequest = (scrollLeft) => {
      let layout = this.layoutRef.current;
      layout.forceTimeScroll(scrollLeft);
    };
    this.handleScrollRequest = (request) => {
      let { rowCoords } = this;
      let layout = this.layoutRef.current;
      let rowId = request.rowId || request.resourceId;
      if (rowCoords) {
        if (rowId) {
          let rowIdToIndex = this.buildRowIndex(this.renderedRowNodes);
          let index5 = rowIdToIndex[rowId];
          if (index5 != null) {
            let scrollTop = request.fromBottom != null ? rowCoords.bottoms[index5] - request.fromBottom : (
              // pixels from bottom edge
              rowCoords.tops[index5]
            );
            layout.forceResourceScroll(scrollTop);
          }
        }
        return true;
      }
      return null;
    };
    this.handleColWidthChange = (colWidths) => {
      this.setState({
        spreadsheetColWidths: colWidths
      });
    };
    this.state = {
      resourceAreaWidth: context.options.resourceAreaWidth,
      spreadsheetColWidths: []
    };
  }
  render() {
    let { props, state, context } = this;
    let { options, viewSpec } = context;
    let { superHeaderRendering, groupSpecs, orderSpecs, isVGrouping, colSpecs } = this.processColOptions(context.options);
    let tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);
    let rowNodes = this.rowNodes = this.buildRowNodes(props.resourceStore, groupSpecs, orderSpecs, isVGrouping, props.resourceEntityExpansions, options.resourcesInitiallyExpanded);
    let { slotMinWidth } = options;
    let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));
    return y(
      ViewContainer,
      { elClasses: [
        "fc-resource-timeline",
        !this.hasNesting(rowNodes) && "fc-resource-timeline-flat",
        "fc-timeline",
        options.eventOverlap === false ? "fc-timeline-overlap-disabled" : "fc-timeline-overlap-enabled"
      ], viewSpec },
      y(ResourceTimelineViewLayout, { ref: this.layoutRef, forPrint: props.forPrint, isHeightAuto: props.isHeightAuto, spreadsheetCols: buildSpreadsheetCols(colSpecs, state.spreadsheetColWidths, ""), spreadsheetHeaderRows: (contentArg) => y(
        SpreadsheetHeader,
        { superHeaderRendering, colSpecs, onColWidthChange: this.handleColWidthChange, rowInnerHeights: contentArg.rowSyncHeights }
      ), spreadsheetBodyRows: (contentArg) => y(_, null, this.renderSpreadsheetRows(rowNodes, colSpecs, contentArg.rowSyncHeights)), timeCols: slatCols, timeHeaderContent: (contentArg) => y(TimelineHeader, { clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, dateProfile: props.dateProfile, tDateProfile, slatCoords: state.slatCoords, rowInnerHeights: contentArg.rowSyncHeights, onMaxCushionWidth: slotMinWidth ? null : this.handleMaxCushionWidth }), timeBodyContent: (contentArg) => y(ResourceTimelineGrid, { dateProfile: props.dateProfile, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, tableMinWidth: contentArg.tableMinWidth, tableColGroupNode: contentArg.tableColGroupNode, expandRows: contentArg.expandRows, tDateProfile, rowNodes, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, resourceStore: props.resourceStore, nextDayThreshold: context.options.nextDayThreshold, rowInnerHeights: contentArg.rowSyncHeights, onSlatCoords: this.handleSlatCoords, onRowCoords: this.handleRowCoords, onScrollLeftRequest: this.handleScrollLeftRequest, onRowHeightChange: contentArg.reportRowHeightChange }) })
    );
  }
  renderSpreadsheetRows(nodes, colSpecs, rowSyncHeights) {
    return nodes.map((node, index5) => {
      if (node.group) {
        return y(SpreadsheetGroupRow, { key: node.id, id: node.id, spreadsheetColCnt: colSpecs.length, isExpanded: node.isExpanded, group: node.group, innerHeight: rowSyncHeights[index5] || "" });
      }
      if (node.resource) {
        return y(SpreadsheetRow, { key: node.id, colSpecs, rowSpans: node.rowSpans, depth: node.depth, isExpanded: node.isExpanded, hasChildren: node.hasChildren, resource: node.resource, innerHeight: rowSyncHeights[index5] || "" });
      }
      return null;
    });
  }
  componentDidMount() {
    this.renderedRowNodes = this.rowNodes;
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  }
  getSnapshotBeforeUpdate() {
    if (!this.props.forPrint) {
      return { resourceScroll: this.queryResourceScroll() };
    }
    return {};
  }
  componentDidUpdate(prevProps, prevState, snapshot) {
    this.renderedRowNodes = this.rowNodes;
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
    if (snapshot.resourceScroll) {
      this.handleScrollRequest(snapshot.resourceScroll);
    }
  }
  componentWillUnmount() {
    this.scrollResponder.detach();
  }
  computeFallbackSlotMinWidth(tDateProfile) {
    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);
  }
  queryResourceScroll() {
    let { rowCoords, renderedRowNodes } = this;
    if (rowCoords) {
      let layout = this.layoutRef.current;
      let trBottoms = rowCoords.bottoms;
      let scrollTop = layout.getResourceScroll();
      let scroll = {};
      for (let i = 0; i < trBottoms.length; i += 1) {
        let rowNode = renderedRowNodes[i];
        let elBottom = trBottoms[i] - scrollTop;
        if (elBottom > 0) {
          scroll.rowId = rowNode.id;
          scroll.fromBottom = elBottom;
          break;
        }
      }
      return scroll;
    }
    return null;
  }
};
ResourceTimelineView.addStateEquality({
  spreadsheetColWidths: isArraysEqual
});
function buildRowIndex(rowNodes) {
  let rowIdToIndex = {};
  for (let i = 0; i < rowNodes.length; i += 1) {
    rowIdToIndex[rowNodes[i].id] = i;
  }
  return rowIdToIndex;
}
function buildSpreadsheetCols(colSpecs, forcedWidths, fallbackWidth = "") {
  return colSpecs.map((colSpec, i) => ({
    className: colSpec.isMain ? "fc-main-col" : "",
    width: forcedWidths[i] || colSpec.width || fallbackWidth
  }));
}
function hasNesting(nodes) {
  for (let node of nodes) {
    if (node.group) {
      return true;
    }
    if (node.resource) {
      if (node.hasChildren) {
        return true;
      }
    }
  }
  return false;
}
function processColOptions(options) {
  let allColSpecs = options.resourceAreaColumns || [];
  let superHeaderRendering = null;
  if (!allColSpecs.length) {
    allColSpecs.push({
      headerClassNames: options.resourceAreaHeaderClassNames,
      headerContent: options.resourceAreaHeaderContent,
      headerDefault: () => "Resources",
      headerDidMount: options.resourceAreaHeaderDidMount,
      headerWillUnmount: options.resourceAreaHeaderWillUnmount
    });
  } else if (options.resourceAreaHeaderContent) {
    superHeaderRendering = {
      headerClassNames: options.resourceAreaHeaderClassNames,
      headerContent: options.resourceAreaHeaderContent,
      headerDidMount: options.resourceAreaHeaderDidMount,
      headerWillUnmount: options.resourceAreaHeaderWillUnmount
    };
  }
  let plainColSpecs = [];
  let groupColSpecs = [];
  let groupSpecs = [];
  let isVGrouping = false;
  for (let colSpec of allColSpecs) {
    if (colSpec.group) {
      groupColSpecs.push(Object.assign(Object.assign({}, colSpec), { cellClassNames: colSpec.cellClassNames || options.resourceGroupLabelClassNames, cellContent: colSpec.cellContent || options.resourceGroupLabelContent, cellDidMount: colSpec.cellDidMount || options.resourceGroupLabelDidMount, cellWillUnmount: colSpec.cellWillUnmount || options.resourceGroupLaneWillUnmount }));
    } else {
      plainColSpecs.push(colSpec);
    }
  }
  let mainColSpec = plainColSpecs[0];
  mainColSpec.isMain = true;
  mainColSpec.cellClassNames = mainColSpec.cellClassNames || options.resourceLabelClassNames;
  mainColSpec.cellContent = mainColSpec.cellContent || options.resourceLabelContent;
  mainColSpec.cellDidMount = mainColSpec.cellDidMount || options.resourceLabelDidMount;
  mainColSpec.cellWillUnmount = mainColSpec.cellWillUnmount || options.resourceLabelWillUnmount;
  if (groupColSpecs.length) {
    groupSpecs = groupColSpecs;
    isVGrouping = true;
  } else {
    let hGroupField = options.resourceGroupField;
    if (hGroupField) {
      groupSpecs.push({
        field: hGroupField,
        labelClassNames: options.resourceGroupLabelClassNames,
        labelContent: options.resourceGroupLabelContent,
        labelDidMount: options.resourceGroupLabelDidMount,
        labelWillUnmount: options.resourceGroupLabelWillUnmount,
        laneClassNames: options.resourceGroupLaneClassNames,
        laneContent: options.resourceGroupLaneContent,
        laneDidMount: options.resourceGroupLaneDidMount,
        laneWillUnmount: options.resourceGroupLaneWillUnmount
      });
    }
  }
  let allOrderSpecs = options.resourceOrder || DEFAULT_RESOURCE_ORDER;
  let plainOrderSpecs = [];
  for (let orderSpec of allOrderSpecs) {
    let isGroup = false;
    for (let groupSpec of groupSpecs) {
      if (groupSpec.field === orderSpec.field) {
        groupSpec.order = orderSpec.order;
        isGroup = true;
        break;
      }
    }
    if (!isGroup) {
      plainOrderSpecs.push(orderSpec);
    }
  }
  return {
    superHeaderRendering,
    isVGrouping,
    groupSpecs,
    colSpecs: groupColSpecs.concat(plainColSpecs),
    orderSpecs: plainOrderSpecs
  };
}
var css_248z2 = ".fc .fc-resource-timeline-divider{cursor:col-resize;width:3px}.fc .fc-resource-group{font-weight:inherit;text-align:inherit}.fc .fc-resource-timeline .fc-resource-group:not([rowspan]){background:var(--fc-neutral-bg-color)}.fc .fc-timeline-lane-frame{position:relative}.fc .fc-timeline-overlap-enabled .fc-timeline-lane-frame .fc-timeline-events{box-sizing:content-box;padding-bottom:10px}.fc-timeline-body-expandrows td.fc-timeline-lane{position:relative}.fc-timeline-body-expandrows .fc-timeline-lane-frame{position:static}.fc-datagrid-cell-frame-liquid{height:100%}.fc-liquid-hack .fc-datagrid-cell-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-datagrid-header .fc-datagrid-cell-frame{align-items:center;display:flex;justify-content:flex-start;position:relative}.fc .fc-datagrid-cell-resizer{bottom:0;cursor:col-resize;position:absolute;top:0;width:5px;z-index:1}.fc .fc-datagrid-cell-cushion{overflow:hidden;padding:8px;white-space:nowrap}.fc .fc-datagrid-expander{cursor:pointer;opacity:.65}.fc .fc-datagrid-expander .fc-icon{display:inline-block;width:1em}.fc .fc-datagrid-expander-placeholder{cursor:auto}.fc .fc-resource-timeline-flat .fc-datagrid-expander-placeholder{display:none}.fc-direction-ltr .fc-datagrid-cell-resizer{right:-3px}.fc-direction-rtl .fc-datagrid-cell-resizer{left:-3px}.fc-direction-ltr .fc-datagrid-expander{margin-right:3px}.fc-direction-rtl .fc-datagrid-expander{margin-left:3px}";
injectStyles(css_248z2);

// node_modules/@fullcalendar/resource-timeline/index.js
var index4 = createPlugin({
  name: "@fullcalendar/resource-timeline",
  premiumReleaseDate: "2024-07-12",
  deps: [
    index,
    index2,
    index3
  ],
  initialView: "resourceTimelineDay",
  views: {
    resourceTimeline: {
      type: "timeline",
      component: ResourceTimelineView,
      needsResourceData: true,
      resourceAreaWidth: "30%",
      resourcesInitiallyExpanded: true,
      eventResizableFromStart: true
      // TODO: not DRY with this same setting in the main timeline config
    },
    resourceTimelineDay: {
      type: "resourceTimeline",
      duration: { days: 1 }
    },
    resourceTimelineWeek: {
      type: "resourceTimeline",
      duration: { weeks: 1 }
    },
    resourceTimelineMonth: {
      type: "resourceTimeline",
      duration: { months: 1 }
    },
    resourceTimelineYear: {
      type: "resourceTimeline",
      duration: { years: 1 }
    }
  }
});
export {
  index4 as default
};
//# sourceMappingURL=@fullcalendar_resource-timeline.js.map
