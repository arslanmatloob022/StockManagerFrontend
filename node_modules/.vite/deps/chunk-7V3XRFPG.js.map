{
  "version": 3,
  "sources": ["../../@fullcalendar/scrollgrid/internal.js"],
  "sourcesContent": ["import { computeEdges, removeElement, findElements, translateRect, computeInnerRect, applyStyle, BaseComponent, setRef, getIsRtlScrollbarOnLeft, Scroller, isPropsEqual, Emitter, DelayedRunner, config, memoizeArraylike, renderMicroColGroup, RefMap, getScrollGridClassNames, getCanVGrowWithinCell, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, memoizeHashlike, computeShrinkWidth, getScrollbarWidths, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual } from '@fullcalendar/core/internal.js';\nimport { createRef, createElement, Fragment } from '@fullcalendar/core/preact.js';\n\n// TODO: assume the el has no borders?\nfunction getScrollCanvasOrigin(scrollEl) {\n    let rect = scrollEl.getBoundingClientRect();\n    let edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n    return {\n        left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n        top: rect.top + edges.borderTop - scrollEl.scrollTop,\n    };\n}\nfunction getScrollFromLeftEdge(el) {\n    let scrollLeft = el.scrollLeft;\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'negative':\n                scrollLeft *= -1; // convert to 'reverse'. fall through...\n            case 'reverse': // scrollLeft is distance between scrollframe's right edge scrollcanvas's right edge\n                scrollLeft = el.scrollWidth - scrollLeft - el.clientWidth;\n        }\n    }\n    return scrollLeft;\n}\nfunction setScrollFromLeftEdge(el, scrollLeft) {\n    let computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl instead?\n    if (computedStyles.direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n            case 'reverse':\n                scrollLeft = el.scrollWidth - scrollLeft;\n                break;\n            case 'negative':\n                scrollLeft = -(el.scrollWidth - scrollLeft);\n                break;\n        }\n    }\n    el.scrollLeft = scrollLeft;\n}\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\nlet _rtlScrollSystem;\nfunction getRtlScrollSystem() {\n    return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\nfunction detectRtlScrollSystem() {\n    let el = document.createElement('div');\n    el.style.position = 'absolute';\n    el.style.top = '-1000px';\n    el.style.width = '100px'; // must be at least the side of scrollbars or you get inaccurate values (#7335)\n    el.style.height = '100px'; // \"\n    el.style.overflow = 'scroll';\n    el.style.direction = 'rtl';\n    let innerEl = document.createElement('div');\n    innerEl.style.width = '200px';\n    innerEl.style.height = '200px';\n    el.appendChild(innerEl);\n    document.body.appendChild(el);\n    let system;\n    if (el.scrollLeft > 0) {\n        system = 'positive'; // scroll is a positive number from the left edge\n    }\n    else {\n        el.scrollLeft = 1;\n        if (el.scrollLeft > 0) {\n            system = 'reverse'; // scroll is a positive number from the right edge\n        }\n        else {\n            system = 'negative'; // scroll is a negative number from the right edge\n        }\n    }\n    removeElement(el);\n    return system;\n}\n\nconst STICKY_SELECTOR = '.fc-sticky';\n/*\nGoes beyond mere position:sticky, allows horizontal centering\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nclass StickyScrolling {\n    constructor(scrollEl, isRtl) {\n        this.scrollEl = scrollEl;\n        this.isRtl = isRtl;\n        this.updateSize = () => {\n            let { scrollEl } = this;\n            let els = findElements(scrollEl, STICKY_SELECTOR);\n            let elGeoms = this.queryElGeoms(els);\n            let viewportWidth = scrollEl.clientWidth;\n            assignStickyPositions(els, elGeoms, viewportWidth);\n        };\n    }\n    queryElGeoms(els) {\n        let { scrollEl, isRtl } = this;\n        let canvasOrigin = getScrollCanvasOrigin(scrollEl);\n        let elGeoms = [];\n        for (let el of els) {\n            let parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!\n            -canvasOrigin.left, -canvasOrigin.top);\n            let elRect = el.getBoundingClientRect();\n            let computedStyles = window.getComputedStyle(el);\n            let textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n            let naturalBound = null;\n            if (textAlign === 'start') {\n                textAlign = isRtl ? 'right' : 'left';\n            }\n            else if (textAlign === 'end') {\n                textAlign = isRtl ? 'left' : 'right';\n            }\n            if (computedStyles.position !== 'sticky') {\n                naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n                -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n            }\n            elGeoms.push({\n                parentBound,\n                naturalBound,\n                elWidth: elRect.width,\n                elHeight: elRect.height,\n                textAlign,\n            });\n        }\n        return elGeoms;\n    }\n}\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n    els.forEach((el, i) => {\n        let { textAlign, elWidth, parentBound } = elGeoms[i];\n        let parentWidth = parentBound.right - parentBound.left;\n        let left;\n        if (textAlign === 'center' &&\n            parentWidth > viewportWidth) {\n            left = (viewportWidth - elWidth) / 2;\n        }\n        else { // if parent container can be completely in view, we don't need stickiness\n            left = '';\n        }\n        applyStyle(el, {\n            left,\n            right: left,\n            top: 0,\n        });\n    });\n}\n\nclass ClippedScroller extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.elRef = createRef();\n        this.state = {\n            xScrollbarWidth: 0,\n            yScrollbarWidth: 0,\n        };\n        this.handleScroller = (scroller) => {\n            this.scroller = scroller;\n            setRef(this.props.scrollerRef, scroller);\n        };\n        this.handleSizing = () => {\n            let { props } = this;\n            if (props.overflowY === 'scroll-hidden') {\n                this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() });\n            }\n            if (props.overflowX === 'scroll-hidden') {\n                this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() });\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n        let overcomeLeft = 0;\n        let overcomeRight = 0;\n        let overcomeBottom = 0;\n        let { overflowX, overflowY } = props;\n        if (props.forPrint) {\n            overflowX = 'visible';\n            overflowY = 'visible';\n        }\n        if (overflowX === 'scroll-hidden') {\n            overcomeBottom = state.xScrollbarWidth;\n        }\n        if (overflowY === 'scroll-hidden') {\n            if (state.yScrollbarWidth != null) {\n                if (isScrollbarOnLeft) {\n                    overcomeLeft = state.yScrollbarWidth;\n                }\n                else {\n                    overcomeRight = state.yScrollbarWidth;\n                }\n            }\n        }\n        return (createElement(\"div\", { ref: this.elRef, className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '') },\n            createElement(Scroller, { ref: this.handleScroller, elRef: this.props.scrollerElRef, overflowX: overflowX === 'scroll-hidden' ? 'scroll' : overflowX, overflowY: overflowY === 'scroll-hidden' ? 'scroll' : overflowY, overcomeLeft: overcomeLeft, overcomeRight: overcomeRight, overcomeBottom: overcomeBottom, maxHeight: typeof props.maxHeight === 'number'\n                    ? (props.maxHeight + (overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0))\n                    : '', liquid: props.liquid, liquidIsAbsolute: true }, props.children)));\n    }\n    componentDidMount() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        if (this.props.forPrint && !prevProps.forPrint) {\n            return { simulateScrollLeft: this.scroller.el.scrollLeft };\n        }\n        return {};\n    }\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        const { props, scroller: { el: scrollerEl } } = this;\n        if (!isPropsEqual(prevProps, props)) { // an external change?\n            this.handleSizing();\n        }\n        if (snapshot.simulateScrollLeft !== undefined) {\n            scrollerEl.style.left = -snapshot.simulateScrollLeft + 'px';\n        }\n        else if (!props.forPrint && prevProps.forPrint) {\n            const restoredScrollLeft = -parseInt(scrollerEl.style.left);\n            scrollerEl.style.left = '';\n            scrollerEl.scrollLeft = restoredScrollLeft;\n        }\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n    }\n    needsXScrolling() {\n        return this.scroller.needsXScrolling();\n    }\n    needsYScrolling() {\n        return this.scroller.needsYScrolling();\n    }\n}\n\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\nclass ScrollListener {\n    constructor(el) {\n        this.el = el;\n        this.emitter = new Emitter();\n        this.isScrolling = false;\n        this.isTouching = false; // user currently has finger down?\n        this.isRecentlyWheeled = false;\n        this.isRecentlyScrolled = false;\n        this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n        this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this));\n        // Handlers\n        // ----------------------------------------------------------------------------------------------\n        this.handleScroll = () => {\n            this.startScroll();\n            this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching);\n            this.isRecentlyScrolled = true;\n            this.scrollWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleWheel = () => {\n            this.isRecentlyWheeled = true;\n            this.wheelWaiter.request(500);\n        };\n        // will fire *before* the scroll event is fired (might not cause a scroll)\n        this.handleTouchStart = () => {\n            this.isTouching = true;\n        };\n        this.handleTouchEnd = () => {\n            this.isTouching = false;\n            // if the user ended their touch, and the scroll area wasn't moving,\n            // we consider this to be the end of the scroll.\n            if (!this.isRecentlyScrolled) {\n                this.endScroll(); // won't fire if already ended\n            }\n        };\n        el.addEventListener('scroll', this.handleScroll);\n        el.addEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.addEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.addEventListener(eventName, this.handleWheel);\n        }\n    }\n    destroy() {\n        let { el } = this;\n        el.removeEventListener('scroll', this.handleScroll);\n        el.removeEventListener('touchstart', this.handleTouchStart, { passive: true });\n        el.removeEventListener('touchend', this.handleTouchEnd);\n        for (let eventName of WHEEL_EVENT_NAMES) {\n            el.removeEventListener(eventName, this.handleWheel);\n        }\n    }\n    // Start / Stop\n    // ----------------------------------------------------------------------------------------------\n    startScroll() {\n        if (!this.isScrolling) {\n            this.isScrolling = true;\n            this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n        }\n    }\n    endScroll() {\n        if (this.isScrolling) {\n            this.emitter.trigger('scrollEnd');\n            this.isScrolling = false;\n            this.isRecentlyScrolled = true;\n            this.isRecentlyWheeled = false;\n            this.scrollWaiter.clear();\n            this.wheelWaiter.clear();\n        }\n    }\n    _handleScrollWaited() {\n        this.isRecentlyScrolled = false;\n        // only end the scroll if not currently touching.\n        // if touching, the scrolling will end later, on touchend.\n        if (!this.isTouching) {\n            this.endScroll(); // won't fire if already ended\n        }\n    }\n    _handleWheelWaited() {\n        this.isRecentlyWheeled = false;\n    }\n}\n\nclass ScrollSyncer {\n    constructor(isVertical, scrollEls) {\n        this.isVertical = isVertical;\n        this.scrollEls = scrollEls;\n        this.isPaused = false;\n        this.scrollListeners = scrollEls.map((el) => this.bindScroller(el));\n    }\n    destroy() {\n        for (let scrollListener of this.scrollListeners) {\n            scrollListener.destroy();\n        }\n    }\n    bindScroller(el) {\n        let { scrollEls, isVertical } = this;\n        let scrollListener = new ScrollListener(el);\n        const onScroll = (isWheel, isTouch) => {\n            if (!this.isPaused) {\n                if (!this.masterEl || (this.masterEl !== el && (isWheel || isTouch))) {\n                    this.assignMaster(el);\n                }\n                if (this.masterEl === el) { // dealing with current\n                    for (let otherEl of scrollEls) {\n                        if (otherEl !== el) {\n                            if (isVertical) {\n                                otherEl.scrollTop = el.scrollTop;\n                            }\n                            else {\n                                otherEl.scrollLeft = el.scrollLeft;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        const onScrollEnd = () => {\n            if (this.masterEl === el) {\n                this.masterEl = null;\n            }\n        };\n        scrollListener.emitter.on('scroll', onScroll);\n        scrollListener.emitter.on('scrollEnd', onScrollEnd);\n        return scrollListener;\n    }\n    assignMaster(el) {\n        this.masterEl = el;\n        for (let scrollListener of this.scrollListeners) {\n            if (scrollListener.el !== el) {\n                scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n            }\n        }\n    }\n    /*\n    will normalize the scrollLeft value\n    */\n    forceScrollLeft(scrollLeft) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            setScrollFromLeftEdge(listener.el, scrollLeft);\n        }\n        this.isPaused = false;\n    }\n    forceScrollTop(top) {\n        this.isPaused = true;\n        for (let listener of this.scrollListeners) {\n            listener.el.scrollTop = top;\n        }\n        this.isPaused = false;\n    }\n}\n\nconfig.SCROLLGRID_RESIZE_INTERVAL = 500;\n/*\nTODO: make <ScrollGridSection> subcomponent\nNOTE: doesn't support collapsibleWidth (which is sortof a hack anyway)\n*/\nclass ScrollGrid extends BaseComponent {\n    constructor() {\n        super(...arguments);\n        this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n        this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n        this.clippedScrollerRefs = new RefMap();\n        // doesn't hold non-scrolling els used just for padding\n        this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n        this.chunkElRefs = new RefMap(this._handleChunkEl.bind(this));\n        this.scrollSyncersBySection = {};\n        this.scrollSyncersByColumn = {};\n        // for row-height-syncing\n        this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n        this.rowInnerMaxHeightMap = new Map();\n        this.anyRowHeightsChanged = false;\n        this.recentSizingCnt = 0;\n        this.state = {\n            shrinkWidths: [],\n            forceYScrollbars: false,\n            forceXScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {},\n            sectionRowMaxHeights: [],\n        };\n        this.handleSizing = (isForcedResize, sectionRowMaxHeightsChanged) => {\n            if (!this.allowSizing()) {\n                return;\n            }\n            if (!sectionRowMaxHeightsChanged) { // something else changed, probably external\n                this.anyRowHeightsChanged = true;\n            }\n            let otherState = {};\n            // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n            if (isForcedResize || (!sectionRowMaxHeightsChanged && !this.rowUnstableMap.size)) {\n                otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights();\n            }\n            this.setState(Object.assign(Object.assign({ shrinkWidths: this.computeShrinkWidths() }, this.computeScrollerDims()), otherState), () => {\n                if (!this.rowUnstableMap.size) {\n                    this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n                }\n            });\n        };\n        this.handleRowHeightChange = (rowEl, isStable) => {\n            let { rowUnstableMap, rowInnerMaxHeightMap } = this;\n            if (!isStable) {\n                rowUnstableMap.set(rowEl, true);\n            }\n            else {\n                rowUnstableMap.delete(rowEl);\n                let innerMaxHeight = getRowInnerMaxHeight(rowEl);\n                if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n                    rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n                    this.anyRowHeightsChanged = true;\n                }\n                if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\n                    this.anyRowHeightsChanged = false;\n                    this.setState({\n                        sectionRowMaxHeights: this.computeSectionRowMaxHeights(),\n                    });\n                }\n            }\n        };\n    }\n    render() {\n        let { props, state, context } = this;\n        let { shrinkWidths } = state;\n        let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]));\n        let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]));\n        let classNames = getScrollGridClassNames(props.liquid, context);\n        this.getDims();\n        // TODO: make DRY\n        let sectionConfigs = props.sections;\n        let configCnt = sectionConfigs.length;\n        let configI = 0;\n        let currentConfig;\n        let headSectionNodes = [];\n        let bodySectionNodes = [];\n        let footSectionNodes = [];\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n            headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n            bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, false));\n            configI += 1;\n        }\n        while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n            footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights, true));\n            configI += 1;\n        }\n        const isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n        const roleAttrs = { role: 'rowgroup' };\n        return createElement('table', {\n            ref: props.elRef,\n            role: 'grid',\n            className: classNames.join(' '),\n        }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', roleAttrs, ...footSectionNodes), isBuggy && createElement('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n    }\n    renderSection(sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights, isHeader) {\n        if ('outerContent' in sectionConfig) {\n            return (createElement(Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));\n        }\n        return (createElement(\"tr\", { key: sectionConfig.key, role: \"presentation\", className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || [], isHeader))));\n    }\n    renderChunk(sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights, isHeader) {\n        if ('outerContent' in chunkConfig) {\n            return (createElement(Fragment, { key: chunkConfig.key }, chunkConfig.outerContent));\n        }\n        let { state } = this;\n        let { scrollerClientWidths, scrollerClientHeights } = state;\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let index = sectionIndex * chunksPerSection + chunkIndex;\n        let sideScrollIndex = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let isVScrollSide = chunkIndex === sideScrollIndex;\n        let isLastSection = sectionIndex === sectionCnt - 1;\n        let forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n        let forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n        let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n        let allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n        let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n        let expandRows = sectionConfig.expandRows && chunkVGrow;\n        let tableMinWidth = (colGroupStat && colGroupStat.totalColMinWidth) || '';\n        let content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth,\n            clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n            clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n            expandRows,\n            syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n            rowSyncHeights: rowHeights,\n            reportRowHeightChange: this.handleRowHeightChange,\n        }, isHeader);\n        let overflowX = forceXScrollbars ? (isLastSection ? 'scroll' : 'scroll-hidden') :\n            !allowXScrolling ? 'hidden' :\n                (isLastSection ? 'auto' : 'scroll-hidden');\n        let overflowY = forceYScrollbars ? (isVScrollSide ? 'scroll' : 'scroll-hidden') :\n            !allowYScrolling ? 'hidden' :\n                (isVScrollSide ? 'auto' : 'scroll-hidden');\n        // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n        // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n        content = (createElement(ClippedScroller, { ref: this.clippedScrollerRefs.createRef(index), scrollerElRef: this.scrollerElRefs.createRef(index), overflowX: overflowX, overflowY: overflowY, forPrint: this.props.forPrint, liquid: chunkVGrow, maxHeight: sectionConfig.maxHeight }, content));\n        return createElement(isHeader ? 'th' : 'td', {\n            key: chunkConfig.key,\n            ref: this.chunkElRefs.createRef(index),\n            role: 'presentation',\n        }, content);\n    }\n    componentDidMount() {\n        this.getStickyScrolling = memoizeArraylike(initStickyScrolling);\n        this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer);\n        this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer);\n        this.updateScrollSyncers();\n        this.handleSizing(false);\n        this.context.addResizeHandler(this.handleSizing);\n    }\n    componentDidUpdate(prevProps, prevState) {\n        this.updateScrollSyncers();\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n    }\n    componentWillUnmount() {\n        this.context.removeResizeHandler(this.handleSizing);\n        this.destroyScrollSyncers();\n    }\n    allowSizing() {\n        let now = new Date();\n        if (!this.lastSizingDate ||\n            now.valueOf() > this.lastSizingDate.valueOf() + config.SCROLLGRID_RESIZE_INTERVAL) {\n            this.lastSizingDate = now;\n            this.recentSizingCnt = 0;\n            return true;\n        }\n        return (this.recentSizingCnt += 1) <= 10;\n    }\n    computeShrinkWidths() {\n        let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]));\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let shrinkWidths = [];\n        colGroupStats.forEach((colGroupStat, i) => {\n            if (colGroupStat.hasShrinkCol) {\n                let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n                shrinkWidths[i] = computeShrinkWidth(chunkEls);\n            }\n        });\n        return shrinkWidths;\n    }\n    // has the side effect of grooming rowInnerMaxHeightMap\n    // TODO: somehow short-circuit if there are no new height changes\n    computeSectionRowMaxHeights() {\n        let newHeightMap = new Map();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sectionRowMaxHeights = [];\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let sectionConfig = this.props.sections[sectionI];\n            let assignableHeights = []; // chunk, row\n            if (sectionConfig && sectionConfig.syncRowHeights) {\n                let rowHeightsByChunk = [];\n                for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                    let index = sectionI * chunksPerSection + chunkI;\n                    let rowHeights = [];\n                    let chunkEl = this.chunkElRefs.currentMap[index];\n                    if (chunkEl) {\n                        rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map((rowEl) => {\n                            let max = getRowInnerMaxHeight(rowEl);\n                            newHeightMap.set(rowEl, max);\n                            return max;\n                        });\n                    }\n                    else {\n                        rowHeights = [];\n                    }\n                    rowHeightsByChunk.push(rowHeights);\n                }\n                let rowCnt = rowHeightsByChunk[0].length;\n                let isEqualRowCnt = true;\n                for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n                    let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\n                    if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) { // skip outer content\n                        isEqualRowCnt = false;\n                        break;\n                    }\n                }\n                if (!isEqualRowCnt) {\n                    let chunkHeightSums = [];\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\n                    }\n                    let maxTotalSum = Math.max(...chunkHeightSums);\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        let rowInChunkCnt = rowHeightsByChunk[chunkI].length;\n                        let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n                        // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n                        let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt);\n                        // whatever is leftover goes to the first row\n                        let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n                        let rowInChunkHeights = [];\n                        let row = 0;\n                        if (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightFirst);\n                            row += 1;\n                        }\n                        while (row < rowInChunkCnt) {\n                            rowInChunkHeights.push(rowInChunkHeightOthers);\n                            row += 1;\n                        }\n                        assignableHeights.push(rowInChunkHeights);\n                    }\n                }\n                else {\n                    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                        assignableHeights.push([]);\n                    }\n                    for (let row = 0; row < rowCnt; row += 1) {\n                        let rowHeightsAcrossChunks = [];\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            let h = rowHeightsByChunk[chunkI][row];\n                            if (h != null) { // protect against outerContent\n                                rowHeightsAcrossChunks.push(h);\n                            }\n                        }\n                        let maxHeight = Math.max(...rowHeightsAcrossChunks);\n                        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                            assignableHeights[chunkI].push(maxHeight);\n                        }\n                    }\n                }\n            }\n            sectionRowMaxHeights.push(assignableHeights);\n        }\n        this.rowInnerMaxHeightMap = newHeightMap;\n        return sectionRowMaxHeights;\n    }\n    computeScrollerDims() {\n        let scrollbarWidth = getScrollbarWidths();\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let sideScrollI = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0;\n        let lastSectionI = sectionCnt - 1;\n        let currentScrollers = this.clippedScrollerRefs.currentMap;\n        let scrollerEls = this.scrollerElRefs.currentMap;\n        let forceYScrollbars = false;\n        let forceXScrollbars = false;\n        let scrollerClientWidths = {};\n        let scrollerClientHeights = {};\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n            let index = sectionI * chunksPerSection + sideScrollI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) { // along last row\n            let index = lastSectionI * chunksPerSection + chunkI;\n            let scroller = currentScrollers[index];\n            if (scroller && scroller.needsXScrolling()) {\n                forceXScrollbars = true;\n                break;\n            }\n        }\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n                let index = sectionI * chunksPerSection + chunkI;\n                let scrollerEl = scrollerEls[index];\n                if (scrollerEl) {\n                    // TODO: weird way to get this. need harness b/c doesn't include table borders\n                    let harnessEl = scrollerEl.parentNode;\n                    scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - ((chunkI === sideScrollI && forceYScrollbars)\n                        ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                    scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - ((sectionI === lastSectionI && forceXScrollbars)\n                        ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                }\n            }\n        }\n        return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights };\n    }\n    updateStickyScrolling() {\n        let { isRtl } = this.context;\n        let argsByKey = this.scrollerElRefs.getAll().map((scrollEl) => [scrollEl, isRtl]);\n        this.getStickyScrolling(argsByKey)\n            .forEach((stickyScrolling) => stickyScrolling.updateSize());\n    }\n    updateScrollSyncers() {\n        let [sectionCnt, chunksPerSection] = this.getDims();\n        let cnt = sectionCnt * chunksPerSection;\n        let scrollElsBySection = {};\n        let scrollElsByColumn = {};\n        let scrollElMap = this.scrollerElRefs.currentMap;\n        for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n            let startIndex = sectionI * chunksPerSection;\n            let endIndex = startIndex + chunksPerSection;\n            scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n        }\n        for (let col = 0; col < chunksPerSection; col += 1) {\n            scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n        }\n        this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n        this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n    }\n    destroyScrollSyncers() {\n        mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n        mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n    }\n    getChunkConfigByIndex(index) {\n        let chunksPerSection = this.getDims()[1];\n        let sectionI = Math.floor(index / chunksPerSection);\n        let chunkI = index % chunksPerSection;\n        let sectionConfig = this.props.sections[sectionI];\n        return sectionConfig && sectionConfig.chunks[chunkI];\n    }\n    forceScrollLeft(col, scrollLeft) {\n        let scrollSyncer = this.scrollSyncersByColumn[col];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollLeft(scrollLeft);\n        }\n    }\n    forceScrollTop(sectionI, scrollTop) {\n        let scrollSyncer = this.scrollSyncersBySection[sectionI];\n        if (scrollSyncer) {\n            scrollSyncer.forceScrollTop(scrollTop);\n        }\n    }\n    _handleChunkEl(chunkEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.elRef, chunkEl);\n        }\n    }\n    _handleScrollerEl(scrollerEl, key) {\n        let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n        if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n            setRef(chunkConfig.scrollerElRef, scrollerEl);\n        }\n    }\n    getDims() {\n        let sectionCnt = this.props.sections.length;\n        let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n        return [sectionCnt, chunksPerSection];\n    }\n}\nScrollGrid.addStateEquality({\n    shrinkWidths: isArraysEqual,\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual,\n});\nfunction sumNumbers(numbers) {\n    let sum = 0;\n    for (let n of numbers) {\n        sum += n;\n    }\n    return sum;\n}\nfunction getRowInnerMaxHeight(rowEl) {\n    let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n    if (innerHeights.length) {\n        return Math.max(...innerHeights);\n    }\n    return 0;\n}\nfunction getElHeight(el) {\n    return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n    let children = colGroupStats.map((colGroupStat, i) => {\n        let width = colGroupStat.width;\n        if (width === 'shrink') {\n            width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n        }\n        return ( // eslint-disable-next-line react/jsx-key\n        createElement(\"col\", { style: { width } }));\n    });\n    return createElement('colgroup', {}, ...children);\n}\nfunction compileColGroupStat(colGroupConfig) {\n    let totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n    let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n    let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n    let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n    return {\n        hasShrinkCol,\n        totalColWidth,\n        totalColMinWidth,\n        allowXScrolling,\n        cols: colGroupConfig.cols,\n        width: colGroupConfig.width,\n    };\n}\nfunction sumColProp(cols, propName) {\n    let total = 0;\n    for (let col of cols) {\n        let val = col[propName];\n        if (typeof val === 'number') {\n            total += val * (col.span || 1);\n        }\n    }\n    return total;\n}\nconst COL_GROUP_STAT_EQUALITY = {\n    cols: isColPropsEqual,\n};\nfunction isColGroupStatsEqual(stat0, stat1) {\n    return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n}\n// for memoizers...\nfunction initScrollSyncer(isVertical, ...scrollEls) {\n    return new ScrollSyncer(isVertical, scrollEls);\n}\nfunction destroyScrollSyncer(scrollSyncer) {\n    scrollSyncer.destroy();\n}\nfunction initStickyScrolling(scrollEl, isRtl) {\n    return new StickyScrolling(scrollEl, isRtl);\n}\n\nexport { ScrollGrid };\n"],
  "mappings": "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",
  "names": ["scrollEl"]
}
