import {
  hasProperty,
  headingRank
} from "./chunk-KVGEKL7O.js";
import {
  convertElement,
  require_extend
} from "./chunk-TQYETJWH.js";
import {
  visit
} from "./chunk-VGG62YDC.js";
import {
  SKIP
} from "./chunk-6XJW5YQ2.js";
import {
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/rehype-autolink-headings/lib/index.js
var import_extend = __toESM(require_extend(), 1);
var contentDefaults = {
  type: "element",
  tagName: "span",
  properties: { className: ["icon", "icon-link"] },
  children: []
};
function rehypeAutolinkHeadings(options = {}) {
  let props = options.properties;
  const behavior = options.behaviour || options.behavior || "prepend";
  const content = options.content || contentDefaults;
  const group = options.group;
  const is = convertElement(options.test);
  let method;
  if (behavior === "wrap") {
    method = wrap;
  } else if (behavior === "before" || behavior === "after") {
    method = around;
  } else {
    if (!props) {
      props = { ariaHidden: "true", tabIndex: -1 };
    }
    method = inject;
  }
  return (tree) => {
    visit(tree, "element", (node, index, parent) => {
      if (headingRank(node) && hasProperty(node, "id") && is(node, index, parent)) {
        return method(node, index, parent);
      }
    });
  };
  function inject(node) {
    node.children[behavior === "prepend" ? "unshift" : "push"](
      create(node, (0, import_extend.default)(true, {}, props), toChildren(content, node))
    );
    return [SKIP];
  }
  function around(node, index, parent) {
    if (typeof index !== "number" || !parent)
      return;
    const link = create(
      node,
      (0, import_extend.default)(true, {}, props),
      toChildren(content, node)
    );
    let nodes = behavior === "before" ? [link, node] : [node, link];
    if (group) {
      const grouping = toNode(group, node);
      if (grouping && !Array.isArray(grouping) && grouping.type === "element") {
        grouping.children = nodes;
        nodes = [grouping];
      }
    }
    parent.children.splice(index, 1, ...nodes);
    return [SKIP, index + nodes.length];
  }
  function wrap(node) {
    node.children = [create(node, (0, import_extend.default)(true, {}, props), node.children)];
    return [SKIP];
  }
  function toChildren(value, node) {
    const result = toNode(value, node);
    return Array.isArray(result) ? result : [result];
  }
  function toNode(value, node) {
    if (typeof value === "function")
      return value(node);
    return (0, import_extend.default)(true, Array.isArray(value) ? [] : {}, value);
  }
  function create(node, props2, children) {
    return {
      type: "element",
      tagName: "a",
      properties: Object.assign({}, props2, {
        // Fix hast types and make them required.
        /* c8 ignore next */
        href: "#" + (node.properties || {}).id
      }),
      children
    };
  }
}
export {
  rehypeAutolinkHeadings as default
};
//# sourceMappingURL=rehype-autolink-headings.js.map
