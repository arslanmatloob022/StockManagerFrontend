import {
  DayTimeColsSlicer,
  TimeCols,
  TimeColsView,
  buildDayRanges,
  buildSlatMetas,
  buildTimeColsModel,
  index as index3
} from "./chunk-ICTWRAIG.js";
import {
  DEFAULT_RESOURCE_ORDER,
  DayResourceTableModel,
  ResourceDayHeader,
  ResourceDayTableModel,
  VResourceJoiner,
  VResourceSplitter,
  flattenResources,
  index as index2
} from "./chunk-Z5MWOR5S.js";
import {
  index
} from "./chunk-XT3PLC24.js";
import {
  DayTableSlicer,
  Table
} from "./chunk-3OLDMAM2.js";
import "./chunk-T7UM46HU.js";
import {
  DateComponent,
  NowTimer,
  createPlugin,
  d,
  mapHash,
  memoize,
  y
} from "./chunk-QXEJWH2N.js";
import "./chunk-2LSFTFF7.js";

// node_modules/@fullcalendar/resource-daygrid/internal.js
var ResourceDayTableJoiner = class extends VResourceJoiner {
  transformSeg(seg, resourceDayTableModel, resourceI) {
    let colRanges = resourceDayTableModel.computeColRanges(seg.firstCol, seg.lastCol, resourceI);
    return colRanges.map((colRange) => Object.assign(Object.assign(Object.assign({}, seg), colRange), { isStart: seg.isStart && colRange.isStart, isEnd: seg.isEnd && colRange.isEnd }));
  }
};
var ResourceDayTable = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.splitter = new VResourceSplitter();
    this.slicers = {};
    this.joiner = new ResourceDayTableJoiner();
    this.tableRef = d();
    this.isHitComboAllowed = (hit0, hit1) => {
      let allowAcrossResources = this.props.resourceDayTableModel.dayTableModel.colCnt === 1;
      return allowAcrossResources || hit0.dateSpan.resourceId === hit1.dateSpan.resourceId;
    };
  }
  render() {
    let { props, context } = this;
    let { resourceDayTableModel, nextDayThreshold, dateProfile } = props;
    let splitProps = this.splitter.splitProps(props);
    this.slicers = mapHash(splitProps, (split, resourceId) => this.slicers[resourceId] || new DayTableSlicer());
    let slicedProps = mapHash(this.slicers, (slicer, resourceId) => slicer.sliceProps(splitProps[resourceId], dateProfile, nextDayThreshold, context, resourceDayTableModel.dayTableModel));
    return y(Table, Object.assign({ forPrint: props.forPrint, ref: this.tableRef }, this.joiner.joinProps(slicedProps, resourceDayTableModel), { cells: resourceDayTableModel.cells, dateProfile, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, isHitComboAllowed: this.isHitComboAllowed }));
  }
};

// node_modules/@fullcalendar/resource-timegrid/internal.js
var ResourceDayTimeColsJoiner = class extends VResourceJoiner {
  transformSeg(seg, resourceDayTable, resourceI) {
    return [
      Object.assign(Object.assign({}, seg), { col: resourceDayTable.computeCol(seg.col, resourceI) })
    ];
  }
};
var ResourceDayTimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.buildDayRanges = memoize(buildDayRanges);
    this.splitter = new VResourceSplitter();
    this.slicers = {};
    this.joiner = new ResourceDayTimeColsJoiner();
    this.timeColsRef = d();
    this.isHitComboAllowed = (hit0, hit1) => {
      let allowAcrossResources = this.dayRanges.length === 1;
      return allowAcrossResources || hit0.dateSpan.resourceId === hit1.dateSpan.resourceId;
    };
  }
  render() {
    let { props, context } = this;
    let { dateEnv, options } = context;
    let { dateProfile, resourceDayTableModel } = props;
    let dayRanges = this.dayRanges = this.buildDayRanges(resourceDayTableModel.dayTableModel, dateProfile, dateEnv);
    let splitProps = this.splitter.splitProps(props);
    this.slicers = mapHash(splitProps, (split, resourceId) => this.slicers[resourceId] || new DayTimeColsSlicer());
    let slicedProps = mapHash(this.slicers, (slicer, resourceId) => slicer.sliceProps(splitProps[resourceId], dateProfile, null, context, dayRanges));
    return (
      // TODO: would move this further down hierarchy, but sliceNowDate needs it
      y(NowTimer, { unit: options.nowIndicator ? "minute" : "day" }, (nowDate, todayRange) => y(TimeCols, Object.assign({ ref: this.timeColsRef }, this.joiner.joinProps(slicedProps, resourceDayTableModel), { dateProfile, axis: props.axis, slotDuration: props.slotDuration, slatMetas: props.slatMetas, cells: resourceDayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate, nowIndicatorSegs: options.nowIndicator && this.buildNowIndicatorSegs(nowDate), todayRange, onScrollTopRequest: props.onScrollTopRequest, forPrint: props.forPrint, onSlatCoords: props.onSlatCoords, isHitComboAllowed: this.isHitComboAllowed })))
    );
  }
  buildNowIndicatorSegs(date) {
    let nonResourceSegs = this.slicers[""].sliceNowDate(date, this.props.dateProfile, this.context.options.nextDayThreshold, this.context, this.dayRanges);
    return this.joiner.expandSegs(this.props.resourceDayTableModel, nonResourceSegs);
  }
};
var ResourceDayTimeColsView = class extends TimeColsView {
  constructor() {
    super(...arguments);
    this.flattenResources = memoize(flattenResources);
    this.buildResourceTimeColsModel = memoize(buildResourceTimeColsModel);
    this.buildSlatMetas = memoize(buildSlatMetas);
  }
  render() {
    let { props, context } = this;
    let { options, dateEnv } = context;
    let { dateProfile } = props;
    let splitProps = this.allDaySplitter.splitProps(props);
    let resourceOrderSpecs = options.resourceOrder || DEFAULT_RESOURCE_ORDER;
    let resources = this.flattenResources(props.resourceStore, resourceOrderSpecs);
    let resourceDayTableModel = this.buildResourceTimeColsModel(dateProfile, context.dateProfileGenerator, resources, options.datesAboveResources, context);
    let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
    let { dayMinWidth } = options;
    let hasAttachedAxis = !dayMinWidth;
    let hasDetachedAxis = dayMinWidth;
    let headerContent = options.dayHeaders && y(ResourceDayHeader, { resources, dates: resourceDayTableModel.dayTableModel.headerDates, dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null });
    let allDayContent = options.allDaySlot !== false && ((contentArg) => y(ResourceDayTable, Object.assign({}, splitProps.allDay, { dateProfile, resourceDayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps())));
    let timeGridContent = (contentArg) => y(ResourceDayTimeCols, Object.assign({}, splitProps.timed, { dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas, resourceDayTableModel, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, forPrint: props.forPrint, onScrollTopRequest: this.handleScrollTopRequest }));
    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, resourceDayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
  }
};
function buildResourceTimeColsModel(dateProfile, dateProfileGenerator, resources, datesAboveResources, context) {
  let dayTable = buildTimeColsModel(dateProfile, dateProfileGenerator);
  return datesAboveResources ? new DayResourceTableModel(dayTable, resources, context) : new ResourceDayTableModel(dayTable, resources, context);
}

// node_modules/@fullcalendar/resource-timegrid/index.js
var index4 = createPlugin({
  name: "@fullcalendar/resource-timegrid",
  premiumReleaseDate: "2024-07-12",
  deps: [
    index,
    index2,
    index3
  ],
  initialView: "resourceTimeGridDay",
  views: {
    resourceTimeGrid: {
      type: "timeGrid",
      component: ResourceDayTimeColsView,
      needsResourceData: true
    },
    resourceTimeGridDay: {
      type: "resourceTimeGrid",
      duration: { days: 1 }
    },
    resourceTimeGridWeek: {
      type: "resourceTimeGrid",
      duration: { weeks: 1 }
    }
  }
});
export {
  index4 as default
};
//# sourceMappingURL=@fullcalendar_resource-timegrid.js.map
