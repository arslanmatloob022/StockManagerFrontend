import { customRef, nextTick, watch } from 'vue-demi';
import { useRoute, useRouter } from 'vue-router';
import { tryOnScopeDispose, toValue } from '@vueuse/shared';

let _hash;
function useRouteHash(defaultValue, {
  mode = "replace",
  route = useRoute(),
  router = useRouter()
} = {}) {
  _hash = route.hash;
  tryOnScopeDispose(() => {
    _hash = void 0;
  });
  let _trigger;
  const proxy = customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        track();
        return _hash || toValue(defaultValue);
      },
      set(v) {
        if (v === _hash)
          return;
        _hash = v === null ? void 0 : v;
        trigger();
        nextTick(() => {
          const { params, query } = route;
          router[toValue(mode)]({ params, query, hash: _hash });
        });
      }
    };
  });
  watch(
    () => route.hash,
    () => {
      _hash = route.hash;
      _trigger();
    },
    { flush: "sync" }
  );
  return proxy;
}

const _cache$1 = /* @__PURE__ */ new WeakMap();
function useRouteParams(name, defaultValue, options = {}) {
  const {
    mode = "replace",
    route = useRoute(),
    router = useRouter(),
    transform = (value) => value
  } = options;
  if (!_cache$1.has(route))
    _cache$1.set(route, /* @__PURE__ */ new Map());
  const _params = _cache$1.get(route);
  tryOnScopeDispose(() => {
    _params.delete(name);
  });
  _params.set(name, route.params[name]);
  let _trigger;
  const proxy = customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        track();
        const data = _params.get(name);
        return transform(data !== void 0 ? data : toValue(defaultValue));
      },
      set(v) {
        if (_params.get(name) === v)
          return;
        _params.set(name, v);
        trigger();
        nextTick(() => {
          const { params, query, hash } = route;
          router[toValue(mode)]({
            params: {
              ...params,
              ...Object.fromEntries(_params.entries())
            },
            query,
            hash
          });
        });
      }
    };
  });
  watch(
    () => route.params[name],
    (v) => {
      _params.set(name, v);
      _trigger();
    },
    { flush: "sync" }
  );
  return proxy;
}

const _cache = /* @__PURE__ */ new WeakMap();
function useRouteQuery(name, defaultValue, options = {}) {
  const {
    mode = "replace",
    route = useRoute(),
    router = useRouter(),
    transform = (value) => value
  } = options;
  if (!_cache.has(route))
    _cache.set(route, /* @__PURE__ */ new Map());
  const _query = _cache.get(route);
  tryOnScopeDispose(() => {
    _query.delete(name);
  });
  _query.set(name, route.query[name]);
  let _trigger;
  const proxy = customRef((track, trigger) => {
    _trigger = trigger;
    return {
      get() {
        track();
        const data = _query.get(name);
        return transform(data !== void 0 ? data : toValue(defaultValue));
      },
      set(v) {
        if (_query.get(name) === v)
          return;
        _query.set(name, v);
        trigger();
        nextTick(() => {
          const { params, query, hash } = route;
          router[toValue(mode)]({
            params,
            query: { ...query, ...Object.fromEntries(_query.entries()) },
            hash
          });
        });
      }
    };
  });
  watch(
    () => route.query[name],
    (v) => {
      _query.set(name, v);
      _trigger();
    },
    { flush: "sync" }
  );
  return proxy;
}

export { useRouteHash, useRouteParams, useRouteQuery };
